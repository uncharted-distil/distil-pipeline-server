// Code generated by protoc-gen-go. DO NOT EDIT.
// source: core.proto

/*
Package pipeline is a generated protocol buffer package.

It is generated from these files:
	core.proto
	pipeline.proto
	primitive.proto
	problem.proto
	value.proto

It has these top-level messages:
	ScoringConfiguration
	Score
	StartSessionRequest
	StartSessionResponse
	EndSessionRequest
	EndSessionResponse
	StartProblemRequest
	StartProblemResponse
	UpdateProblemRequest
	UpdateProblemResponse
	EndProblemRequest
	EndProblemResponse
	SearchPipelinesRequest
	SearchPipelinesResponse
	EndSearchPipelinesRequest
	EndSearchPipelinesResponse
	StopSearchPipelinesRequest
	StopSearchPipelinesResponse
	PipelineSearchScore
	GetSearchPipelinesResultsRequest
	GetSearchPipelinesResultsResponse
	DescribePipelineRequest
	PrimitiveStepDescription
	SubpipelineStepDescription
	StepDescription
	DescribePipelineResponse
	StepProgress
	PipelineRunUser
	ScorePipelineRequest
	ScorePipelineResponse
	GetScorePipelineResultsRequest
	GetScorePipelineResultsResponse
	FitPipelineRequest
	FitPipelineResponse
	GetFitPipelineResultsRequest
	GetFitPipelineResultsResponse
	ProducePipelineRequest
	ProducePipelineResponse
	GetProducePipelineResultsRequest
	GetProducePipelineResultsResponse
	PipelineExportRequest
	PipelineExportResponse
	ListPrimitivesRequest
	ListPrimitivesResponse
	ContainerArgument
	PrimitiveArgument
	DataArgument
	PrimitiveStepArgument
	StepInput
	StepOutput
	PipelineSource
	PipelineDescriptionUser
	PipelineDescriptionInput
	PipelineDescriptionOutput
	PrimitivePipelineDescriptionStep
	SubpipelinePipelineDescriptionStep
	PlaceholderPipelineDescriptionStep
	PipelineDescriptionStep
	PipelineDescription
	Primitive
	ProblemPerformanceMetric
	Problem
	ProblemTarget
	ProblemInput
	ProblemOutputs
	ProblemDescription
	ValueError
	Value
*/
package pipeline

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/protoc-gen-go/descriptor"
import google_protobuf1 "github.com/golang/protobuf/ptypes/timestamp"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type EvaluationMethod int32

const (
	// Default value. Not to be used.
	EvaluationMethod_EVALUATION_METHOD_UNDEFINED EvaluationMethod = 0
	// The following are the only evaluation methods required
	// to be supported for the ScorePipeline call.
	EvaluationMethod_HOLDOUT EvaluationMethod = 1
	EvaluationMethod_K_FOLD  EvaluationMethod = 2
	// The rest are defined to allow expressing internal evaluation
	// methods used by TA2 during pipeline search. If any you are using
	// is missing, feel free to request it to be added.
	EvaluationMethod_LEAVE_ONE_OUT EvaluationMethod = 100
	// Instead of really scoring, a TA2 might predict the score only.
	EvaluationMethod_PREDICTION EvaluationMethod = 101
	// Training data is reused to test as well.
	EvaluationMethod_TRAINING_DATA EvaluationMethod = 102
)

var EvaluationMethod_name = map[int32]string{
	0:   "EVALUATION_METHOD_UNDEFINED",
	1:   "HOLDOUT",
	2:   "K_FOLD",
	100: "LEAVE_ONE_OUT",
	101: "PREDICTION",
	102: "TRAINING_DATA",
}
var EvaluationMethod_value = map[string]int32{
	"EVALUATION_METHOD_UNDEFINED": 0,
	"HOLDOUT":                     1,
	"K_FOLD":                      2,
	"LEAVE_ONE_OUT":               100,
	"PREDICTION":                  101,
	"TRAINING_DATA":               102,
}

func (x EvaluationMethod) String() string {
	return proto.EnumName(EvaluationMethod_name, int32(x))
}
func (EvaluationMethod) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// After "progress" becomes "COMPLETED" or "ERRORED" stream closes.
type Progress int32

const (
	// Default value. Not to be used.
	Progress_PROGRESS_UNKNOWN Progress = 0
	// The process has been scheduled but is pending execution.
	Progress_PENDING Progress = 1
	// The process is currently running. There can be multiple messages with this state
	// (while the process is running).
	Progress_RUNNING Progress = 2
	// The process completed and final results are available.
	Progress_COMPLETED Progress = 3
	// The process failed.
	Progress_ERRORED Progress = 4
)

var Progress_name = map[int32]string{
	0: "PROGRESS_UNKNOWN",
	1: "PENDING",
	2: "RUNNING",
	3: "COMPLETED",
	4: "ERRORED",
}
var Progress_value = map[string]int32{
	"PROGRESS_UNKNOWN": 0,
	"PENDING":          1,
	"RUNNING":          2,
	"COMPLETED":        3,
	"ERRORED":          4,
}

func (x Progress) String() string {
	return proto.EnumName(Progress_name, int32(x))
}
func (Progress) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type ScoringConfiguration struct {
	// The evaluation method to use.
	Method EvaluationMethod `protobuf:"varint,1,opt,name=method,enum=EvaluationMethod" json:"method,omitempty"`
	// Number of folds made, if applicable.
	Folds int32 `protobuf:"varint,2,opt,name=folds" json:"folds,omitempty"`
	// Ratio of train set vs. test set, if applicable.
	TrainTestRatio float64 `protobuf:"fixed64,3,opt,name=train_test_ratio,json=trainTestRatio" json:"train_test_ratio,omitempty"`
	// Shuffle data?  If applicable.
	Shuffle bool `protobuf:"varint,4,opt,name=shuffle" json:"shuffle,omitempty"`
	// Fix random seed to use for shuffling. Optional.
	RandomSeed int32 `protobuf:"varint,5,opt,name=random_seed,json=randomSeed" json:"random_seed,omitempty"`
	// Do stratified k-fold? If applicable.
	Stratified bool `protobuf:"varint,6,opt,name=stratified" json:"stratified,omitempty"`
}

func (m *ScoringConfiguration) Reset()                    { *m = ScoringConfiguration{} }
func (m *ScoringConfiguration) String() string            { return proto.CompactTextString(m) }
func (*ScoringConfiguration) ProtoMessage()               {}
func (*ScoringConfiguration) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ScoringConfiguration) GetMethod() EvaluationMethod {
	if m != nil {
		return m.Method
	}
	return EvaluationMethod_EVALUATION_METHOD_UNDEFINED
}

func (m *ScoringConfiguration) GetFolds() int32 {
	if m != nil {
		return m.Folds
	}
	return 0
}

func (m *ScoringConfiguration) GetTrainTestRatio() float64 {
	if m != nil {
		return m.TrainTestRatio
	}
	return 0
}

func (m *ScoringConfiguration) GetShuffle() bool {
	if m != nil {
		return m.Shuffle
	}
	return false
}

func (m *ScoringConfiguration) GetRandomSeed() int32 {
	if m != nil {
		return m.RandomSeed
	}
	return 0
}

func (m *ScoringConfiguration) GetStratified() bool {
	if m != nil {
		return m.Stratified
	}
	return false
}

type Score struct {
	Metric *ProblemPerformanceMetric `protobuf:"bytes,1,opt,name=metric" json:"metric,omitempty"`
	Value  *Value                    `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
}

func (m *Score) Reset()                    { *m = Score{} }
func (m *Score) String() string            { return proto.CompactTextString(m) }
func (*Score) ProtoMessage()               {}
func (*Score) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Score) GetMetric() *ProblemPerformanceMetric {
	if m != nil {
		return m.Metric
	}
	return nil
}

func (m *Score) GetValue() *Value {
	if m != nil {
		return m.Value
	}
	return nil
}

// Start a new session and share configuration to each other.
// Multiple parallel sessions can exist at the same time.
type StartSessionRequest struct {
	// Some string identifying the name and version of the TA3 system.
	UserAgent string `protobuf:"bytes,1,opt,name=user_agent,json=userAgent" json:"user_agent,omitempty"`
	// Shall be set to "protocol_version" above.
	Version string `protobuf:"bytes,2,opt,name=version" json:"version,omitempty"`
	// Which value types can a TA2 system use to communicate values to a TA3 system?
	// The order is important as TA2 system will try value types in order until one works out,
	// or an error will be returned instead of the value.
	AllowedValueTypes []ValueType `protobuf:"varint,3,rep,packed,name=allowed_value_types,json=allowedValueTypes,enum=ValueType" json:"allowed_value_types,omitempty"`
}

func (m *StartSessionRequest) Reset()                    { *m = StartSessionRequest{} }
func (m *StartSessionRequest) String() string            { return proto.CompactTextString(m) }
func (*StartSessionRequest) ProtoMessage()               {}
func (*StartSessionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *StartSessionRequest) GetUserAgent() string {
	if m != nil {
		return m.UserAgent
	}
	return ""
}

func (m *StartSessionRequest) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *StartSessionRequest) GetAllowedValueTypes() []ValueType {
	if m != nil {
		return m.AllowedValueTypes
	}
	return nil
}

type StartSessionResponse struct {
	// An ID identifying this session. This string should be at least 22 characters
	// long to ensure enough entropy to not be guessable.
	SessionId string `protobuf:"bytes,1,opt,name=session_id,json=sessionId" json:"session_id,omitempty"`
	// Some string identifying the name and version of the TA2 system.
	UserAgent string `protobuf:"bytes,2,opt,name=user_agent,json=userAgent" json:"user_agent,omitempty"`
	// Shall be set to "protocol_version" above.
	Version string `protobuf:"bytes,3,opt,name=version" json:"version,omitempty"`
	// Which value types can a TA3 system use to communicate values to a TA2 system?
	// The order is important as TA3 system will try value types in order until one works out,
	// or an error will be returned instead of the value.
	AllowedValueTypes []ValueType `protobuf:"varint,4,rep,packed,name=allowed_value_types,json=allowedValueTypes,enum=ValueType" json:"allowed_value_types,omitempty"`
}

func (m *StartSessionResponse) Reset()                    { *m = StartSessionResponse{} }
func (m *StartSessionResponse) String() string            { return proto.CompactTextString(m) }
func (*StartSessionResponse) ProtoMessage()               {}
func (*StartSessionResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *StartSessionResponse) GetSessionId() string {
	if m != nil {
		return m.SessionId
	}
	return ""
}

func (m *StartSessionResponse) GetUserAgent() string {
	if m != nil {
		return m.UserAgent
	}
	return ""
}

func (m *StartSessionResponse) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *StartSessionResponse) GetAllowedValueTypes() []ValueType {
	if m != nil {
		return m.AllowedValueTypes
	}
	return nil
}

// Ends the session and releases all resources used by the session.
// Any IDs provided during the session are not usable anymore after this call.
type EndSessionRequest struct {
	SessionId string `protobuf:"bytes,1,opt,name=session_id,json=sessionId" json:"session_id,omitempty"`
}

func (m *EndSessionRequest) Reset()                    { *m = EndSessionRequest{} }
func (m *EndSessionRequest) String() string            { return proto.CompactTextString(m) }
func (*EndSessionRequest) ProtoMessage()               {}
func (*EndSessionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *EndSessionRequest) GetSessionId() string {
	if m != nil {
		return m.SessionId
	}
	return ""
}

type EndSessionResponse struct {
}

func (m *EndSessionResponse) Reset()                    { *m = EndSessionResponse{} }
func (m *EndSessionResponse) String() string            { return proto.CompactTextString(m) }
func (*EndSessionResponse) ProtoMessage()               {}
func (*EndSessionResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

// Starts a new problem (or better, a new problem context inside which a search
// for the solution to the problem is done).
// Multiple parallel problems can be worked on at the same time.
type StartProblemRequest struct {
	SessionId string              `protobuf:"bytes,1,opt,name=session_id,json=sessionId" json:"session_id,omitempty"`
	Problem   *ProblemDescription `protobuf:"bytes,2,opt,name=problem" json:"problem,omitempty"`
}

func (m *StartProblemRequest) Reset()                    { *m = StartProblemRequest{} }
func (m *StartProblemRequest) String() string            { return proto.CompactTextString(m) }
func (*StartProblemRequest) ProtoMessage()               {}
func (*StartProblemRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *StartProblemRequest) GetSessionId() string {
	if m != nil {
		return m.SessionId
	}
	return ""
}

func (m *StartProblemRequest) GetProblem() *ProblemDescription {
	if m != nil {
		return m.Problem
	}
	return nil
}

type StartProblemResponse struct {
	ProblemId string `protobuf:"bytes,1,opt,name=problem_id,json=problemId" json:"problem_id,omitempty"`
}

func (m *StartProblemResponse) Reset()                    { *m = StartProblemResponse{} }
func (m *StartProblemResponse) String() string            { return proto.CompactTextString(m) }
func (*StartProblemResponse) ProtoMessage()               {}
func (*StartProblemResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *StartProblemResponse) GetProblemId() string {
	if m != nil {
		return m.ProblemId
	}
	return ""
}

// Updates problem with new description. This upates problem description also for all
// ongoing pipeline searches associated with this problem. Internal behavior of TA2
// is unspecified: it can simply start a new search using new problem description, or
// it can start modifying pipelines it has already found to new problem description, or
// it can use it to help narrow down onging pipeline search further. In any case, after
// this call returns, all found pipelines for searches associated with this problem
// should be for the updated problem description.
type UpdateProblemRequest struct {
	ProblemId string `protobuf:"bytes,1,opt,name=problem_id,json=problemId" json:"problem_id,omitempty"`
	// New problem description. It has to be provided in full and it replaces existing
	// problem description.
	Problem *ProblemDescription `protobuf:"bytes,2,opt,name=problem" json:"problem,omitempty"`
}

func (m *UpdateProblemRequest) Reset()                    { *m = UpdateProblemRequest{} }
func (m *UpdateProblemRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateProblemRequest) ProtoMessage()               {}
func (*UpdateProblemRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *UpdateProblemRequest) GetProblemId() string {
	if m != nil {
		return m.ProblemId
	}
	return ""
}

func (m *UpdateProblemRequest) GetProblem() *ProblemDescription {
	if m != nil {
		return m.Problem
	}
	return nil
}

type UpdateProblemResponse struct {
}

func (m *UpdateProblemResponse) Reset()                    { *m = UpdateProblemResponse{} }
func (m *UpdateProblemResponse) String() string            { return proto.CompactTextString(m) }
func (*UpdateProblemResponse) ProtoMessage()               {}
func (*UpdateProblemResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

// Ends the problem and releases all resources used by the problem.
// Any pipeline search IDs and pipeline IDs done as part of the problem
// are not usable anymore after this call.
type EndProblemRequest struct {
	ProblemId string `protobuf:"bytes,1,opt,name=problem_id,json=problemId" json:"problem_id,omitempty"`
}

func (m *EndProblemRequest) Reset()                    { *m = EndProblemRequest{} }
func (m *EndProblemRequest) String() string            { return proto.CompactTextString(m) }
func (*EndProblemRequest) ProtoMessage()               {}
func (*EndProblemRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *EndProblemRequest) GetProblemId() string {
	if m != nil {
		return m.ProblemId
	}
	return ""
}

type EndProblemResponse struct {
}

func (m *EndProblemResponse) Reset()                    { *m = EndProblemResponse{} }
func (m *EndProblemResponse) String() string            { return proto.CompactTextString(m) }
func (*EndProblemResponse) ProtoMessage()               {}
func (*EndProblemResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

// Starts a new pipeline search. Found pipelines have not necessary be fitted on the provided
// inputs. Problem description and inputs are used only to help guide the search process.
// Consider found pipelines just a static descriptions of pipelines at this stage.
// Multiple parallel pipeline searches can happen at the same time.
type SearchPipelinesRequest struct {
	// Problem description to use for the pipeline search.
	ProblemId string `protobuf:"bytes,1,opt,name=problem_id,json=problemId" json:"problem_id,omitempty"`
	// A pipeline template to use for search or to execute. If template is ommited, then a
	// regular pipeline search is done. If template consists only of one placeholder step,
	// then a regular pipeline search is done to replace that step. If there is no placeholder
	// step, but template describes a full pipeline with free hyper-parameters, then this
	// call becomes a hyper-paramater tuning call over free hyper-paramaters and found pipelines
	// share the same pipeline, but different hyper-parameter configurations. If there is no
	// placeholder step and all hyper-parameters are fixed as part of the pipeline, then this
	// call only checks the given template and returns the same pipeline back, to be execeuted.
	// This allows fixed computations to be done on data, for example, pipeline can consist
	// of only one primitve with fixed hyper-parameters to execute that one primitive.
	// Moreover, such fully specified pipeline with fixed hyper-parametres can have any
	// inputs and any outputs. Otherwise pipelines have to be from a Dataset container value
	// to predictions.
	Template *PipelineDescription `protobuf:"bytes,2,opt,name=template" json:"template,omitempty"`
	// Pipeline inputs used during pipeline search. They have to point to be Dataset container
	// values. Order matters as each input is mapped to template's input in order. Optional
	// for templates without a placeholder and with all hyper-parameters fixed.
	Inputs []*Value `protobuf:"bytes,3,rep,name=inputs" json:"inputs,omitempty"`
}

func (m *SearchPipelinesRequest) Reset()                    { *m = SearchPipelinesRequest{} }
func (m *SearchPipelinesRequest) String() string            { return proto.CompactTextString(m) }
func (*SearchPipelinesRequest) ProtoMessage()               {}
func (*SearchPipelinesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *SearchPipelinesRequest) GetProblemId() string {
	if m != nil {
		return m.ProblemId
	}
	return ""
}

func (m *SearchPipelinesRequest) GetTemplate() *PipelineDescription {
	if m != nil {
		return m.Template
	}
	return nil
}

func (m *SearchPipelinesRequest) GetInputs() []*Value {
	if m != nil {
		return m.Inputs
	}
	return nil
}

// Call returns immediatelly with the ID. Use "GetFoundPipelines" call to get results.
type SearchPipelinesResponse struct {
	// An ID identifying this pipeline search. This string should be at least 22 characters
	// long to ensure enough entropy to not be guessable.
	SearchId string `protobuf:"bytes,1,opt,name=search_id,json=searchId" json:"search_id,omitempty"`
}

func (m *SearchPipelinesResponse) Reset()                    { *m = SearchPipelinesResponse{} }
func (m *SearchPipelinesResponse) String() string            { return proto.CompactTextString(m) }
func (*SearchPipelinesResponse) ProtoMessage()               {}
func (*SearchPipelinesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *SearchPipelinesResponse) GetSearchId() string {
	if m != nil {
		return m.SearchId
	}
	return ""
}

// Ends the search and releases all resources used by the pipeline search.
// Found pipeline IDs during the search are not usable anymore after this call.
type EndSearchPipelinesRequest struct {
	SearchId string `protobuf:"bytes,1,opt,name=search_id,json=searchId" json:"search_id,omitempty"`
}

func (m *EndSearchPipelinesRequest) Reset()                    { *m = EndSearchPipelinesRequest{} }
func (m *EndSearchPipelinesRequest) String() string            { return proto.CompactTextString(m) }
func (*EndSearchPipelinesRequest) ProtoMessage()               {}
func (*EndSearchPipelinesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *EndSearchPipelinesRequest) GetSearchId() string {
	if m != nil {
		return m.SearchId
	}
	return ""
}

type EndSearchPipelinesResponse struct {
}

func (m *EndSearchPipelinesResponse) Reset()                    { *m = EndSearchPipelinesResponse{} }
func (m *EndSearchPipelinesResponse) String() string            { return proto.CompactTextString(m) }
func (*EndSearchPipelinesResponse) ProtoMessage()               {}
func (*EndSearchPipelinesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

// Stops the search but leaves all pipelines available.
type StopSearchPipelinesRequest struct {
	SearchId string `protobuf:"bytes,1,opt,name=search_id,json=searchId" json:"search_id,omitempty"`
}

func (m *StopSearchPipelinesRequest) Reset()                    { *m = StopSearchPipelinesRequest{} }
func (m *StopSearchPipelinesRequest) String() string            { return proto.CompactTextString(m) }
func (*StopSearchPipelinesRequest) ProtoMessage()               {}
func (*StopSearchPipelinesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *StopSearchPipelinesRequest) GetSearchId() string {
	if m != nil {
		return m.SearchId
	}
	return ""
}

type StopSearchPipelinesResponse struct {
}

func (m *StopSearchPipelinesResponse) Reset()                    { *m = StopSearchPipelinesResponse{} }
func (m *StopSearchPipelinesResponse) String() string            { return proto.CompactTextString(m) }
func (*StopSearchPipelinesResponse) ProtoMessage()               {}
func (*StopSearchPipelinesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

// Decription of a TA2 score done during pipeline search. Because there is a wide range of potential
// approaches TA2 can use to score candidate pipelines this might not capture what your TA2 is doing.
// Feel free to request additions to be able to describe your approch.
type PipelineSearchScore struct {
	ScoringConfiguration *ScoringConfiguration `protobuf:"bytes,1,opt,name=scoring_configuration,json=scoringConfiguration" json:"scoring_configuration,omitempty"`
	Score                *Score                `protobuf:"bytes,2,opt,name=score" json:"score,omitempty"`
}

func (m *PipelineSearchScore) Reset()                    { *m = PipelineSearchScore{} }
func (m *PipelineSearchScore) String() string            { return proto.CompactTextString(m) }
func (*PipelineSearchScore) ProtoMessage()               {}
func (*PipelineSearchScore) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *PipelineSearchScore) GetScoringConfiguration() *ScoringConfiguration {
	if m != nil {
		return m.ScoringConfiguration
	}
	return nil
}

func (m *PipelineSearchScore) GetScore() *Score {
	if m != nil {
		return m.Score
	}
	return nil
}

// Get all pipelines found until now during the search and start receiving any
// new pipeline found as well.
type GetSearchPipelinesResultsRequest struct {
	SearchId string `protobuf:"bytes,1,opt,name=search_id,json=searchId" json:"search_id,omitempty"`
}

func (m *GetSearchPipelinesResultsRequest) Reset()         { *m = GetSearchPipelinesResultsRequest{} }
func (m *GetSearchPipelinesResultsRequest) String() string { return proto.CompactTextString(m) }
func (*GetSearchPipelinesResultsRequest) ProtoMessage()    {}
func (*GetSearchPipelinesResultsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{19}
}

func (m *GetSearchPipelinesResultsRequest) GetSearchId() string {
	if m != nil {
		return m.SearchId
	}
	return ""
}

type GetSearchPipelinesResultsResponse struct {
	PipelineId string `protobuf:"bytes,1,opt,name=pipeline_id,json=pipelineId" json:"pipeline_id,omitempty"`
	// Internal score for this pipeline between 0.0 and 1.0 where 1.0 is the highest score.
	// There is no other meaning to this score and it does not necessary depend on scores
	// listed in the problem description. Optional.
	// Becaue this field is optional, if omitted the default value will be 0. But 0 is a
	// valid value for this field. Because of that you should never omit the field.
	// If you do not have internal score to provide, use NaN for the value of this field
	// to signal that.
	InternalScore float64 `protobuf:"fixed64,2,opt,name=internal_score,json=internalScore" json:"internal_score,omitempty"`
	// TA2 might be able to provide more meaningful scores as well, depending on its
	// approach to pipeline search. Moreover, even same TA2 might not use same scoring
	// approach for all its pipelines. Optional.
	Scores []*PipelineSearchScore `protobuf:"bytes,3,rep,name=scores" json:"scores,omitempty"`
}

func (m *GetSearchPipelinesResultsResponse) Reset()         { *m = GetSearchPipelinesResultsResponse{} }
func (m *GetSearchPipelinesResultsResponse) String() string { return proto.CompactTextString(m) }
func (*GetSearchPipelinesResultsResponse) ProtoMessage()    {}
func (*GetSearchPipelinesResultsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{20}
}

func (m *GetSearchPipelinesResultsResponse) GetPipelineId() string {
	if m != nil {
		return m.PipelineId
	}
	return ""
}

func (m *GetSearchPipelinesResultsResponse) GetInternalScore() float64 {
	if m != nil {
		return m.InternalScore
	}
	return 0
}

func (m *GetSearchPipelinesResultsResponse) GetScores() []*PipelineSearchScore {
	if m != nil {
		return m.Scores
	}
	return nil
}

// Request a detailed description of the found pipeline.
type DescribePipelineRequest struct {
	PipelineId string `protobuf:"bytes,1,opt,name=pipeline_id,json=pipelineId" json:"pipeline_id,omitempty"`
}

func (m *DescribePipelineRequest) Reset()                    { *m = DescribePipelineRequest{} }
func (m *DescribePipelineRequest) String() string            { return proto.CompactTextString(m) }
func (*DescribePipelineRequest) ProtoMessage()               {}
func (*DescribePipelineRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *DescribePipelineRequest) GetPipelineId() string {
	if m != nil {
		return m.PipelineId
	}
	return ""
}

type PrimitiveStepDescription struct {
	// Selected value for free pipeline hyper-parameters.
	Hyperparams map[string]*Value `protobuf:"bytes,1,rep,name=hyperparams" json:"hyperparams,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *PrimitiveStepDescription) Reset()                    { *m = PrimitiveStepDescription{} }
func (m *PrimitiveStepDescription) String() string            { return proto.CompactTextString(m) }
func (*PrimitiveStepDescription) ProtoMessage()               {}
func (*PrimitiveStepDescription) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *PrimitiveStepDescription) GetHyperparams() map[string]*Value {
	if m != nil {
		return m.Hyperparams
	}
	return nil
}

type SubpipelineStepDescription struct {
	// Each step in a sub-pipeline has description as well. In order of steps in the sub-pipeline.
	Steps []*StepDescription `protobuf:"bytes,1,rep,name=steps" json:"steps,omitempty"`
}

func (m *SubpipelineStepDescription) Reset()                    { *m = SubpipelineStepDescription{} }
func (m *SubpipelineStepDescription) String() string            { return proto.CompactTextString(m) }
func (*SubpipelineStepDescription) ProtoMessage()               {}
func (*SubpipelineStepDescription) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *SubpipelineStepDescription) GetSteps() []*StepDescription {
	if m != nil {
		return m.Steps
	}
	return nil
}

type StepDescription struct {
	// Types that are valid to be assigned to Step:
	//	*StepDescription_Primitive
	//	*StepDescription_Pipeline
	Step isStepDescription_Step `protobuf_oneof:"step"`
}

func (m *StepDescription) Reset()                    { *m = StepDescription{} }
func (m *StepDescription) String() string            { return proto.CompactTextString(m) }
func (*StepDescription) ProtoMessage()               {}
func (*StepDescription) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

type isStepDescription_Step interface {
	isStepDescription_Step()
}

type StepDescription_Primitive struct {
	Primitive *PrimitiveStepDescription `protobuf:"bytes,1,opt,name=primitive,oneof"`
}
type StepDescription_Pipeline struct {
	Pipeline *SubpipelineStepDescription `protobuf:"bytes,2,opt,name=pipeline,oneof"`
}

func (*StepDescription_Primitive) isStepDescription_Step() {}
func (*StepDescription_Pipeline) isStepDescription_Step()  {}

func (m *StepDescription) GetStep() isStepDescription_Step {
	if m != nil {
		return m.Step
	}
	return nil
}

func (m *StepDescription) GetPrimitive() *PrimitiveStepDescription {
	if x, ok := m.GetStep().(*StepDescription_Primitive); ok {
		return x.Primitive
	}
	return nil
}

func (m *StepDescription) GetPipeline() *SubpipelineStepDescription {
	if x, ok := m.GetStep().(*StepDescription_Pipeline); ok {
		return x.Pipeline
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*StepDescription) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _StepDescription_OneofMarshaler, _StepDescription_OneofUnmarshaler, _StepDescription_OneofSizer, []interface{}{
		(*StepDescription_Primitive)(nil),
		(*StepDescription_Pipeline)(nil),
	}
}

func _StepDescription_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*StepDescription)
	// step
	switch x := m.Step.(type) {
	case *StepDescription_Primitive:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Primitive); err != nil {
			return err
		}
	case *StepDescription_Pipeline:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Pipeline); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("StepDescription.Step has unexpected type %T", x)
	}
	return nil
}

func _StepDescription_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*StepDescription)
	switch tag {
	case 1: // step.primitive
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PrimitiveStepDescription)
		err := b.DecodeMessage(msg)
		m.Step = &StepDescription_Primitive{msg}
		return true, err
	case 2: // step.pipeline
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SubpipelineStepDescription)
		err := b.DecodeMessage(msg)
		m.Step = &StepDescription_Pipeline{msg}
		return true, err
	default:
		return false, nil
	}
}

func _StepDescription_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*StepDescription)
	// step
	switch x := m.Step.(type) {
	case *StepDescription_Primitive:
		s := proto.Size(x.Primitive)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *StepDescription_Pipeline:
		s := proto.Size(x.Pipeline)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type DescribePipelineResponse struct {
	// A pipeline description. Nested pipelines should be fully described as well.
	Pipeline *PipelineDescription `protobuf:"bytes,1,opt,name=pipeline" json:"pipeline,omitempty"`
	// Each step in a pipeline has description as well. In order of steps in the pipeline.
	Steps []*StepDescription `protobuf:"bytes,2,rep,name=steps" json:"steps,omitempty"`
}

func (m *DescribePipelineResponse) Reset()                    { *m = DescribePipelineResponse{} }
func (m *DescribePipelineResponse) String() string            { return proto.CompactTextString(m) }
func (*DescribePipelineResponse) ProtoMessage()               {}
func (*DescribePipelineResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *DescribePipelineResponse) GetPipeline() *PipelineDescription {
	if m != nil {
		return m.Pipeline
	}
	return nil
}

func (m *DescribePipelineResponse) GetSteps() []*StepDescription {
	if m != nil {
		return m.Steps
	}
	return nil
}

type StepProgress struct {
	Progress Progress `protobuf:"varint,1,opt,name=progress,enum=Progress" json:"progress,omitempty"`
	// If step failed, why.
	Failure string                      `protobuf:"bytes,2,opt,name=failure" json:"failure,omitempty"`
	Start   *google_protobuf1.Timestamp `protobuf:"bytes,3,opt,name=start" json:"start,omitempty"`
	End     *google_protobuf1.Timestamp `protobuf:"bytes,4,opt,name=end" json:"end,omitempty"`
	// If step is a sub-pipeline, then this list contains progress for each step in the sub-pipeline, in order.
	// List can be incomplete while the process is in progress.
	Steps []*StepProgress `protobuf:"bytes,5,rep,name=steps" json:"steps,omitempty"`
}

func (m *StepProgress) Reset()                    { *m = StepProgress{} }
func (m *StepProgress) String() string            { return proto.CompactTextString(m) }
func (*StepProgress) ProtoMessage()               {}
func (*StepProgress) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

func (m *StepProgress) GetProgress() Progress {
	if m != nil {
		return m.Progress
	}
	return Progress_PROGRESS_UNKNOWN
}

func (m *StepProgress) GetFailure() string {
	if m != nil {
		return m.Failure
	}
	return ""
}

func (m *StepProgress) GetStart() *google_protobuf1.Timestamp {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *StepProgress) GetEnd() *google_protobuf1.Timestamp {
	if m != nil {
		return m.End
	}
	return nil
}

func (m *StepProgress) GetSteps() []*StepProgress {
	if m != nil {
		return m.Steps
	}
	return nil
}

// User associated with the run of the pipeline.
type PipelineRunUser struct {
	// A UUID of the user. It does not have to map to any real ID, just that it is possible
	// to connect mutliple pipeline actions by the same user together, if necessary.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// Was this run because pipeline was choosen by this user.
	Choosen bool `protobuf:"varint,2,opt,name=choosen" json:"choosen,omitempty"`
	// Textual reason provided by the user why the run was choosen by this user.
	Reason string `protobuf:"bytes,3,opt,name=reason" json:"reason,omitempty"`
}

func (m *PipelineRunUser) Reset()                    { *m = PipelineRunUser{} }
func (m *PipelineRunUser) String() string            { return proto.CompactTextString(m) }
func (*PipelineRunUser) ProtoMessage()               {}
func (*PipelineRunUser) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }

func (m *PipelineRunUser) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *PipelineRunUser) GetChoosen() bool {
	if m != nil {
		return m.Choosen
	}
	return false
}

func (m *PipelineRunUser) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

// Request pipeline to be scored given inputs. Inputs have to be Dataset container values
// and pipeline outputs have to be predictions. It can internally run multiple fit + produce runs
// of the pipeline on permutations of inputs data (e.g., for cross-validation). This is also
// why we cannot expose outputs here.
type ScorePipelineRequest struct {
	PipelineId         string                      `protobuf:"bytes,1,opt,name=pipeline_id,json=pipelineId" json:"pipeline_id,omitempty"`
	Inputs             []*Value                    `protobuf:"bytes,2,rep,name=inputs" json:"inputs,omitempty"`
	PerformanceMetrics []*ProblemPerformanceMetric `protobuf:"bytes,3,rep,name=performance_metrics,json=performanceMetrics" json:"performance_metrics,omitempty"`
	// Any users associated with this call itself. Optional.
	Users         []*PipelineRunUser    `protobuf:"bytes,4,rep,name=users" json:"users,omitempty"`
	Configuration *ScoringConfiguration `protobuf:"bytes,5,opt,name=configuration" json:"configuration,omitempty"`
}

func (m *ScorePipelineRequest) Reset()                    { *m = ScorePipelineRequest{} }
func (m *ScorePipelineRequest) String() string            { return proto.CompactTextString(m) }
func (*ScorePipelineRequest) ProtoMessage()               {}
func (*ScorePipelineRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{28} }

func (m *ScorePipelineRequest) GetPipelineId() string {
	if m != nil {
		return m.PipelineId
	}
	return ""
}

func (m *ScorePipelineRequest) GetInputs() []*Value {
	if m != nil {
		return m.Inputs
	}
	return nil
}

func (m *ScorePipelineRequest) GetPerformanceMetrics() []*ProblemPerformanceMetric {
	if m != nil {
		return m.PerformanceMetrics
	}
	return nil
}

func (m *ScorePipelineRequest) GetUsers() []*PipelineRunUser {
	if m != nil {
		return m.Users
	}
	return nil
}

func (m *ScorePipelineRequest) GetConfiguration() *ScoringConfiguration {
	if m != nil {
		return m.Configuration
	}
	return nil
}

type ScorePipelineResponse struct {
	RequestId string `protobuf:"bytes,1,opt,name=request_id,json=requestId" json:"request_id,omitempty"`
}

func (m *ScorePipelineResponse) Reset()                    { *m = ScorePipelineResponse{} }
func (m *ScorePipelineResponse) String() string            { return proto.CompactTextString(m) }
func (*ScorePipelineResponse) ProtoMessage()               {}
func (*ScorePipelineResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{29} }

func (m *ScorePipelineResponse) GetRequestId() string {
	if m != nil {
		return m.RequestId
	}
	return ""
}

// Get all score results computed until now and start receiving any
// new score results computed as well.
type GetScorePipelineResultsRequest struct {
	RequestId string `protobuf:"bytes,1,opt,name=request_id,json=requestId" json:"request_id,omitempty"`
}

func (m *GetScorePipelineResultsRequest) Reset()                    { *m = GetScorePipelineResultsRequest{} }
func (m *GetScorePipelineResultsRequest) String() string            { return proto.CompactTextString(m) }
func (*GetScorePipelineResultsRequest) ProtoMessage()               {}
func (*GetScorePipelineResultsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{30} }

func (m *GetScorePipelineResultsRequest) GetRequestId() string {
	if m != nil {
		return m.RequestId
	}
	return ""
}

type GetScorePipelineResultsResponse struct {
	// Overall process progress.
	Progress Progress `protobuf:"varint,1,opt,name=progress,enum=Progress" json:"progress,omitempty"`
	// Failure which prevented scoring.
	Failure string                      `protobuf:"bytes,2,opt,name=failure" json:"failure,omitempty"`
	Start   *google_protobuf1.Timestamp `protobuf:"bytes,3,opt,name=start" json:"start,omitempty"`
	End     *google_protobuf1.Timestamp `protobuf:"bytes,4,opt,name=end" json:"end,omitempty"`
	// List of score results. List can be incomplete while the process is in progress.
	Scores []*Score `protobuf:"bytes,5,rep,name=scores" json:"scores,omitempty"`
}

func (m *GetScorePipelineResultsResponse) Reset()         { *m = GetScorePipelineResultsResponse{} }
func (m *GetScorePipelineResultsResponse) String() string { return proto.CompactTextString(m) }
func (*GetScorePipelineResultsResponse) ProtoMessage()    {}
func (*GetScorePipelineResultsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{31}
}

func (m *GetScorePipelineResultsResponse) GetProgress() Progress {
	if m != nil {
		return m.Progress
	}
	return Progress_PROGRESS_UNKNOWN
}

func (m *GetScorePipelineResultsResponse) GetFailure() string {
	if m != nil {
		return m.Failure
	}
	return ""
}

func (m *GetScorePipelineResultsResponse) GetStart() *google_protobuf1.Timestamp {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *GetScorePipelineResultsResponse) GetEnd() *google_protobuf1.Timestamp {
	if m != nil {
		return m.End
	}
	return nil
}

func (m *GetScorePipelineResultsResponse) GetScores() []*Score {
	if m != nil {
		return m.Scores
	}
	return nil
}

// Fit the pipeline on given inputs. If a pipeline is already fitted on inputs this is a noop
// (if no additional outputs should be exposed). This can happen when TA2 fits the pipeline
// already during pipeline search phase.
type FitPipelineRequest struct {
	PipelineId string   `protobuf:"bytes,1,opt,name=pipeline_id,json=pipelineId" json:"pipeline_id,omitempty"`
	Inputs     []*Value `protobuf:"bytes,2,rep,name=inputs" json:"inputs,omitempty"`
	// List of data references of step outputs which should be exposed to the TA3 system.
	// If you want to expose outputs of the whole pipeline (e.g., predictions themselves),
	// list them here as well. These can be recursive data references like "steps.1.steps.4.produce"
	// to point to an output inside a sub-pipeline.
	ExposeOutputs []string `protobuf:"bytes,3,rep,name=expose_outputs,json=exposeOutputs" json:"expose_outputs,omitempty"`
	// Which value types should be used for exposing outputs. If not provided, the allowed
	// value types list from hello call is used instead.
	// The order is important as TA2 system will try value types in order until one works out,
	// or an error will be returned instead of the value. An error exposing a value does not stop
	// the overall process.
	ExposeValueTypes []ValueType `protobuf:"varint,4,rep,packed,name=expose_value_types,json=exposeValueTypes,enum=ValueType" json:"expose_value_types,omitempty"`
	// Any users associated with this call itself. Optional.
	Users []*PipelineRunUser `protobuf:"bytes,5,rep,name=users" json:"users,omitempty"`
}

func (m *FitPipelineRequest) Reset()                    { *m = FitPipelineRequest{} }
func (m *FitPipelineRequest) String() string            { return proto.CompactTextString(m) }
func (*FitPipelineRequest) ProtoMessage()               {}
func (*FitPipelineRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{32} }

func (m *FitPipelineRequest) GetPipelineId() string {
	if m != nil {
		return m.PipelineId
	}
	return ""
}

func (m *FitPipelineRequest) GetInputs() []*Value {
	if m != nil {
		return m.Inputs
	}
	return nil
}

func (m *FitPipelineRequest) GetExposeOutputs() []string {
	if m != nil {
		return m.ExposeOutputs
	}
	return nil
}

func (m *FitPipelineRequest) GetExposeValueTypes() []ValueType {
	if m != nil {
		return m.ExposeValueTypes
	}
	return nil
}

func (m *FitPipelineRequest) GetUsers() []*PipelineRunUser {
	if m != nil {
		return m.Users
	}
	return nil
}

type FitPipelineResponse struct {
	RequestId string `protobuf:"bytes,1,opt,name=request_id,json=requestId" json:"request_id,omitempty"`
}

func (m *FitPipelineResponse) Reset()                    { *m = FitPipelineResponse{} }
func (m *FitPipelineResponse) String() string            { return proto.CompactTextString(m) }
func (*FitPipelineResponse) ProtoMessage()               {}
func (*FitPipelineResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{33} }

func (m *FitPipelineResponse) GetRequestId() string {
	if m != nil {
		return m.RequestId
	}
	return ""
}

// Get all fitting results computed until now and start receiving any
// new fitting results computed as well.
type GetFitPipelineResultsRequest struct {
	RequestId string `protobuf:"bytes,1,opt,name=request_id,json=requestId" json:"request_id,omitempty"`
}

func (m *GetFitPipelineResultsRequest) Reset()                    { *m = GetFitPipelineResultsRequest{} }
func (m *GetFitPipelineResultsRequest) String() string            { return proto.CompactTextString(m) }
func (*GetFitPipelineResultsRequest) ProtoMessage()               {}
func (*GetFitPipelineResultsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{34} }

func (m *GetFitPipelineResultsRequest) GetRequestId() string {
	if m != nil {
		return m.RequestId
	}
	return ""
}

type GetFitPipelineResultsResponse struct {
	// Overall process progress.
	Progress Progress `protobuf:"varint,1,opt,name=progress,enum=Progress" json:"progress,omitempty"`
	// Failure which prevented pipeline to run at all.
	Failure string                      `protobuf:"bytes,2,opt,name=failure" json:"failure,omitempty"`
	Start   *google_protobuf1.Timestamp `protobuf:"bytes,3,opt,name=start" json:"start,omitempty"`
	End     *google_protobuf1.Timestamp `protobuf:"bytes,4,opt,name=end" json:"end,omitempty"`
	// The ist contains progress for each step in the pipeline, in order.
	// List can be incomplete while the process is in progress.
	Steps []*StepProgress `protobuf:"bytes,5,rep,name=steps" json:"steps,omitempty"`
	// A mapping between data references of step outputs and values.
	ExposedOutputs map[string]*Value `protobuf:"bytes,6,rep,name=exposed_outputs,json=exposedOutputs" json:"exposed_outputs,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *GetFitPipelineResultsResponse) Reset()                    { *m = GetFitPipelineResultsResponse{} }
func (m *GetFitPipelineResultsResponse) String() string            { return proto.CompactTextString(m) }
func (*GetFitPipelineResultsResponse) ProtoMessage()               {}
func (*GetFitPipelineResultsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{35} }

func (m *GetFitPipelineResultsResponse) GetProgress() Progress {
	if m != nil {
		return m.Progress
	}
	return Progress_PROGRESS_UNKNOWN
}

func (m *GetFitPipelineResultsResponse) GetFailure() string {
	if m != nil {
		return m.Failure
	}
	return ""
}

func (m *GetFitPipelineResultsResponse) GetStart() *google_protobuf1.Timestamp {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *GetFitPipelineResultsResponse) GetEnd() *google_protobuf1.Timestamp {
	if m != nil {
		return m.End
	}
	return nil
}

func (m *GetFitPipelineResultsResponse) GetSteps() []*StepProgress {
	if m != nil {
		return m.Steps
	}
	return nil
}

func (m *GetFitPipelineResultsResponse) GetExposedOutputs() map[string]*Value {
	if m != nil {
		return m.ExposedOutputs
	}
	return nil
}

// Produce the pipeline on given inputs. A pipeline has to be fitted for this to be possible
// (even if it is full of just transformations).
type ProducePipelineRequest struct {
	PipelineId string   `protobuf:"bytes,1,opt,name=pipeline_id,json=pipelineId" json:"pipeline_id,omitempty"`
	Inputs     []*Value `protobuf:"bytes,2,rep,name=inputs" json:"inputs,omitempty"`
	// List of data references of step outputs which should be exposed to the TA3 system.
	// If you want to expose outputs of the whole pipeline (e.g., predictions themselves),
	// list them here as well. These can be recursive data references like "steps.1.steps.4.produce"
	// to point to an output inside a sub-pipeline.
	ExposeOutputs []string `protobuf:"bytes,3,rep,name=expose_outputs,json=exposeOutputs" json:"expose_outputs,omitempty"`
	// Which value types should be used for exposing outputs. If not provided, the allowed
	// value types list from hello call is used instead.
	// The order is important as TA2 system will try value types in order until one works out,
	// or an error will be returned instead of the value. An error exposing a value does not stop
	// the overall process.
	ExposeValueTypes []ValueType `protobuf:"varint,4,rep,packed,name=expose_value_types,json=exposeValueTypes,enum=ValueType" json:"expose_value_types,omitempty"`
	// Any users associated with this call itself. Optional.
	Users []*PipelineRunUser `protobuf:"bytes,5,rep,name=users" json:"users,omitempty"`
}

func (m *ProducePipelineRequest) Reset()                    { *m = ProducePipelineRequest{} }
func (m *ProducePipelineRequest) String() string            { return proto.CompactTextString(m) }
func (*ProducePipelineRequest) ProtoMessage()               {}
func (*ProducePipelineRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{36} }

func (m *ProducePipelineRequest) GetPipelineId() string {
	if m != nil {
		return m.PipelineId
	}
	return ""
}

func (m *ProducePipelineRequest) GetInputs() []*Value {
	if m != nil {
		return m.Inputs
	}
	return nil
}

func (m *ProducePipelineRequest) GetExposeOutputs() []string {
	if m != nil {
		return m.ExposeOutputs
	}
	return nil
}

func (m *ProducePipelineRequest) GetExposeValueTypes() []ValueType {
	if m != nil {
		return m.ExposeValueTypes
	}
	return nil
}

func (m *ProducePipelineRequest) GetUsers() []*PipelineRunUser {
	if m != nil {
		return m.Users
	}
	return nil
}

type ProducePipelineResponse struct {
	RequestId string `protobuf:"bytes,1,opt,name=request_id,json=requestId" json:"request_id,omitempty"`
}

func (m *ProducePipelineResponse) Reset()                    { *m = ProducePipelineResponse{} }
func (m *ProducePipelineResponse) String() string            { return proto.CompactTextString(m) }
func (*ProducePipelineResponse) ProtoMessage()               {}
func (*ProducePipelineResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{37} }

func (m *ProducePipelineResponse) GetRequestId() string {
	if m != nil {
		return m.RequestId
	}
	return ""
}

// Get all producing results computed until now and start receiving any
// new producing results computed as well.
type GetProducePipelineResultsRequest struct {
	RequestId string `protobuf:"bytes,1,opt,name=request_id,json=requestId" json:"request_id,omitempty"`
}

func (m *GetProducePipelineResultsRequest) Reset()         { *m = GetProducePipelineResultsRequest{} }
func (m *GetProducePipelineResultsRequest) String() string { return proto.CompactTextString(m) }
func (*GetProducePipelineResultsRequest) ProtoMessage()    {}
func (*GetProducePipelineResultsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{38}
}

func (m *GetProducePipelineResultsRequest) GetRequestId() string {
	if m != nil {
		return m.RequestId
	}
	return ""
}

type GetProducePipelineResultsResponse struct {
	// Overall process progress.
	Progress Progress `protobuf:"varint,1,opt,name=progress,enum=Progress" json:"progress,omitempty"`
	// Failure which prevented pipeline to run at all.
	Failure string                      `protobuf:"bytes,2,opt,name=failure" json:"failure,omitempty"`
	Start   *google_protobuf1.Timestamp `protobuf:"bytes,3,opt,name=start" json:"start,omitempty"`
	End     *google_protobuf1.Timestamp `protobuf:"bytes,4,opt,name=end" json:"end,omitempty"`
	// The ist contains progress for each step in the pipeline, in order.
	// List can be incomplete while the process is in progress.
	Steps []*StepProgress `protobuf:"bytes,5,rep,name=steps" json:"steps,omitempty"`
	// A mapping between data references of step outputs and values.
	ExposedOutputs map[string]*Value `protobuf:"bytes,6,rep,name=exposed_outputs,json=exposedOutputs" json:"exposed_outputs,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *GetProducePipelineResultsResponse) Reset()         { *m = GetProducePipelineResultsResponse{} }
func (m *GetProducePipelineResultsResponse) String() string { return proto.CompactTextString(m) }
func (*GetProducePipelineResultsResponse) ProtoMessage()    {}
func (*GetProducePipelineResultsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{39}
}

func (m *GetProducePipelineResultsResponse) GetProgress() Progress {
	if m != nil {
		return m.Progress
	}
	return Progress_PROGRESS_UNKNOWN
}

func (m *GetProducePipelineResultsResponse) GetFailure() string {
	if m != nil {
		return m.Failure
	}
	return ""
}

func (m *GetProducePipelineResultsResponse) GetStart() *google_protobuf1.Timestamp {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *GetProducePipelineResultsResponse) GetEnd() *google_protobuf1.Timestamp {
	if m != nil {
		return m.End
	}
	return nil
}

func (m *GetProducePipelineResultsResponse) GetSteps() []*StepProgress {
	if m != nil {
		return m.Steps
	}
	return nil
}

func (m *GetProducePipelineResultsResponse) GetExposedOutputs() map[string]*Value {
	if m != nil {
		return m.ExposedOutputs
	}
	return nil
}

// Exports a pipeline for evaluaton purposes based on NIST specifications.
type PipelineExportRequest struct {
	// Found pipeline to export.
	PipelineId string `protobuf:"bytes,1,opt,name=pipeline_id,json=pipelineId" json:"pipeline_id,omitempty"`
	// Pipeline rank to be used for the exported pipeline. Each exported pipeline
	// has rank metadata associated with it. There has to be at least one pipeline
	// exported and only one can and should have rank 1.
	Rank int32 `protobuf:"varint,2,opt,name=rank" json:"rank,omitempty"`
}

func (m *PipelineExportRequest) Reset()                    { *m = PipelineExportRequest{} }
func (m *PipelineExportRequest) String() string            { return proto.CompactTextString(m) }
func (*PipelineExportRequest) ProtoMessage()               {}
func (*PipelineExportRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{40} }

func (m *PipelineExportRequest) GetPipelineId() string {
	if m != nil {
		return m.PipelineId
	}
	return ""
}

func (m *PipelineExportRequest) GetRank() int32 {
	if m != nil {
		return m.Rank
	}
	return 0
}

type PipelineExportResponse struct {
}

func (m *PipelineExportResponse) Reset()                    { *m = PipelineExportResponse{} }
func (m *PipelineExportResponse) String() string            { return proto.CompactTextString(m) }
func (*PipelineExportResponse) ProtoMessage()               {}
func (*PipelineExportResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{41} }

// List all primitives known to TA2, their IDs, versions, names, and digests. Using this
// information TA3 knows which primitives to put into pipeline templates. To narrow down
// potential primitives to use TA3 can also first ask TA3 to do a pipeline search and then
// observe which primitives TA2 is using. If more metadata about primitives is needed,
// TA3 can use results of this call to map primitives to metadata (from Python code or
// primitive annotations) on its own.
type ListPrimitivesRequest struct {
	SessionId string `protobuf:"bytes,1,opt,name=session_id,json=sessionId" json:"session_id,omitempty"`
}

func (m *ListPrimitivesRequest) Reset()                    { *m = ListPrimitivesRequest{} }
func (m *ListPrimitivesRequest) String() string            { return proto.CompactTextString(m) }
func (*ListPrimitivesRequest) ProtoMessage()               {}
func (*ListPrimitivesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{42} }

func (m *ListPrimitivesRequest) GetSessionId() string {
	if m != nil {
		return m.SessionId
	}
	return ""
}

type ListPrimitivesResponse struct {
	Primitives []*Primitive `protobuf:"bytes,1,rep,name=primitives" json:"primitives,omitempty"`
}

func (m *ListPrimitivesResponse) Reset()                    { *m = ListPrimitivesResponse{} }
func (m *ListPrimitivesResponse) String() string            { return proto.CompactTextString(m) }
func (*ListPrimitivesResponse) ProtoMessage()               {}
func (*ListPrimitivesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{43} }

func (m *ListPrimitivesResponse) GetPrimitives() []*Primitive {
	if m != nil {
		return m.Primitives
	}
	return nil
}

var E_ProtocolVersion = &proto.ExtensionDesc{
	ExtendedType:  (*google_protobuf.FileOptions)(nil),
	ExtensionType: (*string)(nil),
	Field:         54100,
	Name:          "protocol_version",
	Tag:           "bytes,54100,opt,name=protocol_version,json=protocolVersion",
	Filename:      "core.proto",
}

func init() {
	proto.RegisterType((*ScoringConfiguration)(nil), "ScoringConfiguration")
	proto.RegisterType((*Score)(nil), "Score")
	proto.RegisterType((*StartSessionRequest)(nil), "StartSessionRequest")
	proto.RegisterType((*StartSessionResponse)(nil), "StartSessionResponse")
	proto.RegisterType((*EndSessionRequest)(nil), "EndSessionRequest")
	proto.RegisterType((*EndSessionResponse)(nil), "EndSessionResponse")
	proto.RegisterType((*StartProblemRequest)(nil), "StartProblemRequest")
	proto.RegisterType((*StartProblemResponse)(nil), "StartProblemResponse")
	proto.RegisterType((*UpdateProblemRequest)(nil), "UpdateProblemRequest")
	proto.RegisterType((*UpdateProblemResponse)(nil), "UpdateProblemResponse")
	proto.RegisterType((*EndProblemRequest)(nil), "EndProblemRequest")
	proto.RegisterType((*EndProblemResponse)(nil), "EndProblemResponse")
	proto.RegisterType((*SearchPipelinesRequest)(nil), "SearchPipelinesRequest")
	proto.RegisterType((*SearchPipelinesResponse)(nil), "SearchPipelinesResponse")
	proto.RegisterType((*EndSearchPipelinesRequest)(nil), "EndSearchPipelinesRequest")
	proto.RegisterType((*EndSearchPipelinesResponse)(nil), "EndSearchPipelinesResponse")
	proto.RegisterType((*StopSearchPipelinesRequest)(nil), "StopSearchPipelinesRequest")
	proto.RegisterType((*StopSearchPipelinesResponse)(nil), "StopSearchPipelinesResponse")
	proto.RegisterType((*PipelineSearchScore)(nil), "PipelineSearchScore")
	proto.RegisterType((*GetSearchPipelinesResultsRequest)(nil), "GetSearchPipelinesResultsRequest")
	proto.RegisterType((*GetSearchPipelinesResultsResponse)(nil), "GetSearchPipelinesResultsResponse")
	proto.RegisterType((*DescribePipelineRequest)(nil), "DescribePipelineRequest")
	proto.RegisterType((*PrimitiveStepDescription)(nil), "PrimitiveStepDescription")
	proto.RegisterType((*SubpipelineStepDescription)(nil), "SubpipelineStepDescription")
	proto.RegisterType((*StepDescription)(nil), "StepDescription")
	proto.RegisterType((*DescribePipelineResponse)(nil), "DescribePipelineResponse")
	proto.RegisterType((*StepProgress)(nil), "StepProgress")
	proto.RegisterType((*PipelineRunUser)(nil), "PipelineRunUser")
	proto.RegisterType((*ScorePipelineRequest)(nil), "ScorePipelineRequest")
	proto.RegisterType((*ScorePipelineResponse)(nil), "ScorePipelineResponse")
	proto.RegisterType((*GetScorePipelineResultsRequest)(nil), "GetScorePipelineResultsRequest")
	proto.RegisterType((*GetScorePipelineResultsResponse)(nil), "GetScorePipelineResultsResponse")
	proto.RegisterType((*FitPipelineRequest)(nil), "FitPipelineRequest")
	proto.RegisterType((*FitPipelineResponse)(nil), "FitPipelineResponse")
	proto.RegisterType((*GetFitPipelineResultsRequest)(nil), "GetFitPipelineResultsRequest")
	proto.RegisterType((*GetFitPipelineResultsResponse)(nil), "GetFitPipelineResultsResponse")
	proto.RegisterType((*ProducePipelineRequest)(nil), "ProducePipelineRequest")
	proto.RegisterType((*ProducePipelineResponse)(nil), "ProducePipelineResponse")
	proto.RegisterType((*GetProducePipelineResultsRequest)(nil), "GetProducePipelineResultsRequest")
	proto.RegisterType((*GetProducePipelineResultsResponse)(nil), "GetProducePipelineResultsResponse")
	proto.RegisterType((*PipelineExportRequest)(nil), "PipelineExportRequest")
	proto.RegisterType((*PipelineExportResponse)(nil), "PipelineExportResponse")
	proto.RegisterType((*ListPrimitivesRequest)(nil), "ListPrimitivesRequest")
	proto.RegisterType((*ListPrimitivesResponse)(nil), "ListPrimitivesResponse")
	proto.RegisterEnum("EvaluationMethod", EvaluationMethod_name, EvaluationMethod_value)
	proto.RegisterEnum("Progress", Progress_name, Progress_value)
	proto.RegisterExtension(E_ProtocolVersion)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Core service

type CoreClient interface {
	StartSession(ctx context.Context, in *StartSessionRequest, opts ...grpc.CallOption) (*StartSessionResponse, error)
	EndSession(ctx context.Context, in *EndSessionRequest, opts ...grpc.CallOption) (*EndSessionResponse, error)
	StartProblem(ctx context.Context, in *StartProblemRequest, opts ...grpc.CallOption) (*StartProblemResponse, error)
	UpdateProblem(ctx context.Context, in *UpdateProblemRequest, opts ...grpc.CallOption) (*UpdateProblemResponse, error)
	EndProblem(ctx context.Context, in *EndProblemRequest, opts ...grpc.CallOption) (*EndProblemResponse, error)
	SearchPipelines(ctx context.Context, in *SearchPipelinesRequest, opts ...grpc.CallOption) (*SearchPipelinesResponse, error)
	GetSearchPipelinesResults(ctx context.Context, in *GetSearchPipelinesResultsRequest, opts ...grpc.CallOption) (Core_GetSearchPipelinesResultsClient, error)
	EndSearchPipelines(ctx context.Context, in *EndSearchPipelinesRequest, opts ...grpc.CallOption) (*EndSearchPipelinesResponse, error)
	StopSearchPipelines(ctx context.Context, in *StopSearchPipelinesRequest, opts ...grpc.CallOption) (*StopSearchPipelinesResponse, error)
	DescribePipeline(ctx context.Context, in *DescribePipelineRequest, opts ...grpc.CallOption) (*DescribePipelineResponse, error)
	ScorePipeline(ctx context.Context, in *ScorePipelineRequest, opts ...grpc.CallOption) (*ScorePipelineResponse, error)
	GetScorePipelineResults(ctx context.Context, in *GetScorePipelineResultsRequest, opts ...grpc.CallOption) (Core_GetScorePipelineResultsClient, error)
	FitPipeline(ctx context.Context, in *FitPipelineRequest, opts ...grpc.CallOption) (*FitPipelineResponse, error)
	GetFitPipelineResults(ctx context.Context, in *GetFitPipelineResultsRequest, opts ...grpc.CallOption) (Core_GetFitPipelineResultsClient, error)
	ProducePipeline(ctx context.Context, in *ProducePipelineRequest, opts ...grpc.CallOption) (*ProducePipelineResponse, error)
	GetProducePipelineResults(ctx context.Context, in *GetProducePipelineResultsRequest, opts ...grpc.CallOption) (Core_GetProducePipelineResultsClient, error)
	PipelineExport(ctx context.Context, in *PipelineExportRequest, opts ...grpc.CallOption) (*PipelineExportResponse, error)
	ListPrimitives(ctx context.Context, in *ListPrimitivesRequest, opts ...grpc.CallOption) (*ListPrimitivesResponse, error)
}

type coreClient struct {
	cc *grpc.ClientConn
}

func NewCoreClient(cc *grpc.ClientConn) CoreClient {
	return &coreClient{cc}
}

func (c *coreClient) StartSession(ctx context.Context, in *StartSessionRequest, opts ...grpc.CallOption) (*StartSessionResponse, error) {
	out := new(StartSessionResponse)
	err := grpc.Invoke(ctx, "/Core/StartSession", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreClient) EndSession(ctx context.Context, in *EndSessionRequest, opts ...grpc.CallOption) (*EndSessionResponse, error) {
	out := new(EndSessionResponse)
	err := grpc.Invoke(ctx, "/Core/EndSession", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreClient) StartProblem(ctx context.Context, in *StartProblemRequest, opts ...grpc.CallOption) (*StartProblemResponse, error) {
	out := new(StartProblemResponse)
	err := grpc.Invoke(ctx, "/Core/StartProblem", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreClient) UpdateProblem(ctx context.Context, in *UpdateProblemRequest, opts ...grpc.CallOption) (*UpdateProblemResponse, error) {
	out := new(UpdateProblemResponse)
	err := grpc.Invoke(ctx, "/Core/UpdateProblem", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreClient) EndProblem(ctx context.Context, in *EndProblemRequest, opts ...grpc.CallOption) (*EndProblemResponse, error) {
	out := new(EndProblemResponse)
	err := grpc.Invoke(ctx, "/Core/EndProblem", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreClient) SearchPipelines(ctx context.Context, in *SearchPipelinesRequest, opts ...grpc.CallOption) (*SearchPipelinesResponse, error) {
	out := new(SearchPipelinesResponse)
	err := grpc.Invoke(ctx, "/Core/SearchPipelines", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreClient) GetSearchPipelinesResults(ctx context.Context, in *GetSearchPipelinesResultsRequest, opts ...grpc.CallOption) (Core_GetSearchPipelinesResultsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Core_serviceDesc.Streams[0], c.cc, "/Core/GetSearchPipelinesResults", opts...)
	if err != nil {
		return nil, err
	}
	x := &coreGetSearchPipelinesResultsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Core_GetSearchPipelinesResultsClient interface {
	Recv() (*GetSearchPipelinesResultsResponse, error)
	grpc.ClientStream
}

type coreGetSearchPipelinesResultsClient struct {
	grpc.ClientStream
}

func (x *coreGetSearchPipelinesResultsClient) Recv() (*GetSearchPipelinesResultsResponse, error) {
	m := new(GetSearchPipelinesResultsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *coreClient) EndSearchPipelines(ctx context.Context, in *EndSearchPipelinesRequest, opts ...grpc.CallOption) (*EndSearchPipelinesResponse, error) {
	out := new(EndSearchPipelinesResponse)
	err := grpc.Invoke(ctx, "/Core/EndSearchPipelines", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreClient) StopSearchPipelines(ctx context.Context, in *StopSearchPipelinesRequest, opts ...grpc.CallOption) (*StopSearchPipelinesResponse, error) {
	out := new(StopSearchPipelinesResponse)
	err := grpc.Invoke(ctx, "/Core/StopSearchPipelines", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreClient) DescribePipeline(ctx context.Context, in *DescribePipelineRequest, opts ...grpc.CallOption) (*DescribePipelineResponse, error) {
	out := new(DescribePipelineResponse)
	err := grpc.Invoke(ctx, "/Core/DescribePipeline", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreClient) ScorePipeline(ctx context.Context, in *ScorePipelineRequest, opts ...grpc.CallOption) (*ScorePipelineResponse, error) {
	out := new(ScorePipelineResponse)
	err := grpc.Invoke(ctx, "/Core/ScorePipeline", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreClient) GetScorePipelineResults(ctx context.Context, in *GetScorePipelineResultsRequest, opts ...grpc.CallOption) (Core_GetScorePipelineResultsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Core_serviceDesc.Streams[1], c.cc, "/Core/GetScorePipelineResults", opts...)
	if err != nil {
		return nil, err
	}
	x := &coreGetScorePipelineResultsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Core_GetScorePipelineResultsClient interface {
	Recv() (*GetScorePipelineResultsResponse, error)
	grpc.ClientStream
}

type coreGetScorePipelineResultsClient struct {
	grpc.ClientStream
}

func (x *coreGetScorePipelineResultsClient) Recv() (*GetScorePipelineResultsResponse, error) {
	m := new(GetScorePipelineResultsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *coreClient) FitPipeline(ctx context.Context, in *FitPipelineRequest, opts ...grpc.CallOption) (*FitPipelineResponse, error) {
	out := new(FitPipelineResponse)
	err := grpc.Invoke(ctx, "/Core/FitPipeline", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreClient) GetFitPipelineResults(ctx context.Context, in *GetFitPipelineResultsRequest, opts ...grpc.CallOption) (Core_GetFitPipelineResultsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Core_serviceDesc.Streams[2], c.cc, "/Core/GetFitPipelineResults", opts...)
	if err != nil {
		return nil, err
	}
	x := &coreGetFitPipelineResultsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Core_GetFitPipelineResultsClient interface {
	Recv() (*GetFitPipelineResultsResponse, error)
	grpc.ClientStream
}

type coreGetFitPipelineResultsClient struct {
	grpc.ClientStream
}

func (x *coreGetFitPipelineResultsClient) Recv() (*GetFitPipelineResultsResponse, error) {
	m := new(GetFitPipelineResultsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *coreClient) ProducePipeline(ctx context.Context, in *ProducePipelineRequest, opts ...grpc.CallOption) (*ProducePipelineResponse, error) {
	out := new(ProducePipelineResponse)
	err := grpc.Invoke(ctx, "/Core/ProducePipeline", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreClient) GetProducePipelineResults(ctx context.Context, in *GetProducePipelineResultsRequest, opts ...grpc.CallOption) (Core_GetProducePipelineResultsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Core_serviceDesc.Streams[3], c.cc, "/Core/GetProducePipelineResults", opts...)
	if err != nil {
		return nil, err
	}
	x := &coreGetProducePipelineResultsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Core_GetProducePipelineResultsClient interface {
	Recv() (*GetProducePipelineResultsResponse, error)
	grpc.ClientStream
}

type coreGetProducePipelineResultsClient struct {
	grpc.ClientStream
}

func (x *coreGetProducePipelineResultsClient) Recv() (*GetProducePipelineResultsResponse, error) {
	m := new(GetProducePipelineResultsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *coreClient) PipelineExport(ctx context.Context, in *PipelineExportRequest, opts ...grpc.CallOption) (*PipelineExportResponse, error) {
	out := new(PipelineExportResponse)
	err := grpc.Invoke(ctx, "/Core/PipelineExport", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreClient) ListPrimitives(ctx context.Context, in *ListPrimitivesRequest, opts ...grpc.CallOption) (*ListPrimitivesResponse, error) {
	out := new(ListPrimitivesResponse)
	err := grpc.Invoke(ctx, "/Core/ListPrimitives", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Core service

type CoreServer interface {
	StartSession(context.Context, *StartSessionRequest) (*StartSessionResponse, error)
	EndSession(context.Context, *EndSessionRequest) (*EndSessionResponse, error)
	StartProblem(context.Context, *StartProblemRequest) (*StartProblemResponse, error)
	UpdateProblem(context.Context, *UpdateProblemRequest) (*UpdateProblemResponse, error)
	EndProblem(context.Context, *EndProblemRequest) (*EndProblemResponse, error)
	SearchPipelines(context.Context, *SearchPipelinesRequest) (*SearchPipelinesResponse, error)
	GetSearchPipelinesResults(*GetSearchPipelinesResultsRequest, Core_GetSearchPipelinesResultsServer) error
	EndSearchPipelines(context.Context, *EndSearchPipelinesRequest) (*EndSearchPipelinesResponse, error)
	StopSearchPipelines(context.Context, *StopSearchPipelinesRequest) (*StopSearchPipelinesResponse, error)
	DescribePipeline(context.Context, *DescribePipelineRequest) (*DescribePipelineResponse, error)
	ScorePipeline(context.Context, *ScorePipelineRequest) (*ScorePipelineResponse, error)
	GetScorePipelineResults(*GetScorePipelineResultsRequest, Core_GetScorePipelineResultsServer) error
	FitPipeline(context.Context, *FitPipelineRequest) (*FitPipelineResponse, error)
	GetFitPipelineResults(*GetFitPipelineResultsRequest, Core_GetFitPipelineResultsServer) error
	ProducePipeline(context.Context, *ProducePipelineRequest) (*ProducePipelineResponse, error)
	GetProducePipelineResults(*GetProducePipelineResultsRequest, Core_GetProducePipelineResultsServer) error
	PipelineExport(context.Context, *PipelineExportRequest) (*PipelineExportResponse, error)
	ListPrimitives(context.Context, *ListPrimitivesRequest) (*ListPrimitivesResponse, error)
}

func RegisterCoreServer(s *grpc.Server, srv CoreServer) {
	s.RegisterService(&_Core_serviceDesc, srv)
}

func _Core_StartSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).StartSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Core/StartSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).StartSession(ctx, req.(*StartSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Core_EndSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EndSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).EndSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Core/EndSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).EndSession(ctx, req.(*EndSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Core_StartProblem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartProblemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).StartProblem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Core/StartProblem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).StartProblem(ctx, req.(*StartProblemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Core_UpdateProblem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateProblemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).UpdateProblem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Core/UpdateProblem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).UpdateProblem(ctx, req.(*UpdateProblemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Core_EndProblem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EndProblemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).EndProblem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Core/EndProblem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).EndProblem(ctx, req.(*EndProblemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Core_SearchPipelines_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchPipelinesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).SearchPipelines(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Core/SearchPipelines",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).SearchPipelines(ctx, req.(*SearchPipelinesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Core_GetSearchPipelinesResults_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetSearchPipelinesResultsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CoreServer).GetSearchPipelinesResults(m, &coreGetSearchPipelinesResultsServer{stream})
}

type Core_GetSearchPipelinesResultsServer interface {
	Send(*GetSearchPipelinesResultsResponse) error
	grpc.ServerStream
}

type coreGetSearchPipelinesResultsServer struct {
	grpc.ServerStream
}

func (x *coreGetSearchPipelinesResultsServer) Send(m *GetSearchPipelinesResultsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Core_EndSearchPipelines_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EndSearchPipelinesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).EndSearchPipelines(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Core/EndSearchPipelines",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).EndSearchPipelines(ctx, req.(*EndSearchPipelinesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Core_StopSearchPipelines_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopSearchPipelinesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).StopSearchPipelines(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Core/StopSearchPipelines",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).StopSearchPipelines(ctx, req.(*StopSearchPipelinesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Core_DescribePipeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribePipelineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).DescribePipeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Core/DescribePipeline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).DescribePipeline(ctx, req.(*DescribePipelineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Core_ScorePipeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScorePipelineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).ScorePipeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Core/ScorePipeline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).ScorePipeline(ctx, req.(*ScorePipelineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Core_GetScorePipelineResults_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetScorePipelineResultsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CoreServer).GetScorePipelineResults(m, &coreGetScorePipelineResultsServer{stream})
}

type Core_GetScorePipelineResultsServer interface {
	Send(*GetScorePipelineResultsResponse) error
	grpc.ServerStream
}

type coreGetScorePipelineResultsServer struct {
	grpc.ServerStream
}

func (x *coreGetScorePipelineResultsServer) Send(m *GetScorePipelineResultsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Core_FitPipeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FitPipelineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).FitPipeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Core/FitPipeline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).FitPipeline(ctx, req.(*FitPipelineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Core_GetFitPipelineResults_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetFitPipelineResultsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CoreServer).GetFitPipelineResults(m, &coreGetFitPipelineResultsServer{stream})
}

type Core_GetFitPipelineResultsServer interface {
	Send(*GetFitPipelineResultsResponse) error
	grpc.ServerStream
}

type coreGetFitPipelineResultsServer struct {
	grpc.ServerStream
}

func (x *coreGetFitPipelineResultsServer) Send(m *GetFitPipelineResultsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Core_ProducePipeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProducePipelineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).ProducePipeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Core/ProducePipeline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).ProducePipeline(ctx, req.(*ProducePipelineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Core_GetProducePipelineResults_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetProducePipelineResultsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CoreServer).GetProducePipelineResults(m, &coreGetProducePipelineResultsServer{stream})
}

type Core_GetProducePipelineResultsServer interface {
	Send(*GetProducePipelineResultsResponse) error
	grpc.ServerStream
}

type coreGetProducePipelineResultsServer struct {
	grpc.ServerStream
}

func (x *coreGetProducePipelineResultsServer) Send(m *GetProducePipelineResultsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Core_PipelineExport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PipelineExportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).PipelineExport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Core/PipelineExport",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).PipelineExport(ctx, req.(*PipelineExportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Core_ListPrimitives_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPrimitivesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).ListPrimitives(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Core/ListPrimitives",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).ListPrimitives(ctx, req.(*ListPrimitivesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Core_serviceDesc = grpc.ServiceDesc{
	ServiceName: "Core",
	HandlerType: (*CoreServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StartSession",
			Handler:    _Core_StartSession_Handler,
		},
		{
			MethodName: "EndSession",
			Handler:    _Core_EndSession_Handler,
		},
		{
			MethodName: "StartProblem",
			Handler:    _Core_StartProblem_Handler,
		},
		{
			MethodName: "UpdateProblem",
			Handler:    _Core_UpdateProblem_Handler,
		},
		{
			MethodName: "EndProblem",
			Handler:    _Core_EndProblem_Handler,
		},
		{
			MethodName: "SearchPipelines",
			Handler:    _Core_SearchPipelines_Handler,
		},
		{
			MethodName: "EndSearchPipelines",
			Handler:    _Core_EndSearchPipelines_Handler,
		},
		{
			MethodName: "StopSearchPipelines",
			Handler:    _Core_StopSearchPipelines_Handler,
		},
		{
			MethodName: "DescribePipeline",
			Handler:    _Core_DescribePipeline_Handler,
		},
		{
			MethodName: "ScorePipeline",
			Handler:    _Core_ScorePipeline_Handler,
		},
		{
			MethodName: "FitPipeline",
			Handler:    _Core_FitPipeline_Handler,
		},
		{
			MethodName: "ProducePipeline",
			Handler:    _Core_ProducePipeline_Handler,
		},
		{
			MethodName: "PipelineExport",
			Handler:    _Core_PipelineExport_Handler,
		},
		{
			MethodName: "ListPrimitives",
			Handler:    _Core_ListPrimitives_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetSearchPipelinesResults",
			Handler:       _Core_GetSearchPipelinesResults_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetScorePipelineResults",
			Handler:       _Core_GetScorePipelineResults_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetFitPipelineResults",
			Handler:       _Core_GetFitPipelineResults_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetProducePipelineResults",
			Handler:       _Core_GetProducePipelineResults_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "core.proto",
}

func init() { proto.RegisterFile("core.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1925 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x58, 0x4f, 0x73, 0xeb, 0x48,
	0x11, 0xb7, 0x9c, 0xd8, 0x1b, 0xb7, 0x37, 0x8e, 0xde, 0xf8, 0xef, 0x53, 0xf2, 0x92, 0xac, 0xa8,
	0x47, 0x85, 0x57, 0xcb, 0x6c, 0x9e, 0x81, 0xb7, 0x79, 0xa1, 0xb6, 0x96, 0x6c, 0xac, 0x24, 0xde,
	0xcd, 0xb3, 0x5d, 0xb2, 0x13, 0xa8, 0xe5, 0x20, 0x14, 0x6b, 0x9c, 0xa8, 0xd6, 0x96, 0x84, 0x24,
	0x3f, 0xc8, 0x89, 0x2a, 0x4e, 0x40, 0x15, 0xc5, 0x89, 0x03, 0x57, 0x0e, 0x1c, 0x38, 0x71, 0xe1,
	0x6b, 0x70, 0xda, 0x23, 0xc5, 0x61, 0x3f, 0x09, 0x25, 0xcd, 0x8c, 0xff, 0xc8, 0xb2, 0xe2, 0x6c,
	0x51, 0x14, 0xec, 0x4d, 0xd3, 0xd3, 0xdd, 0xd3, 0xdd, 0xd3, 0xea, 0xfe, 0x4d, 0x03, 0xf4, 0x6d,
	0x97, 0x60, 0xc7, 0xb5, 0x7d, 0x5b, 0xda, 0xbf, 0xb5, 0xed, 0xdb, 0x21, 0xf9, 0x20, 0x5c, 0xdd,
	0x8c, 0x07, 0x1f, 0x18, 0xc4, 0xeb, 0xbb, 0xa6, 0xe3, 0xdb, 0x2e, 0xe3, 0xd8, 0x8b, 0x72, 0xf8,
	0xe6, 0x88, 0x78, 0xbe, 0x3e, 0x72, 0x18, 0x43, 0xc1, 0x31, 0x1d, 0x32, 0x34, 0x2d, 0xae, 0x72,
	0xcb, 0x71, 0xcd, 0x91, 0xe9, 0x9b, 0x6f, 0x39, 0x61, 0xd3, 0x71, 0xed, 0x9b, 0x21, 0x19, 0xb1,
	0x65, 0xfe, 0xad, 0x3e, 0x1c, 0xb3, 0x3d, 0xf9, 0x9f, 0x02, 0x94, 0xba, 0x7d, 0xdb, 0x35, 0xad,
	0xdb, 0x53, 0xdb, 0x1a, 0x98, 0xb7, 0x63, 0x57, 0xf7, 0x4d, 0xdb, 0x42, 0xdf, 0x81, 0xec, 0x88,
	0xf8, 0x77, 0xb6, 0x51, 0x13, 0xf6, 0x85, 0x83, 0x42, 0xfd, 0x09, 0x56, 0x02, 0xb9, 0x70, 0xf3,
	0x4d, 0xb8, 0xa1, 0x32, 0x06, 0x54, 0x82, 0xcc, 0xc0, 0x1e, 0x1a, 0x5e, 0x2d, 0xbd, 0x2f, 0x1c,
	0x64, 0x54, 0xba, 0x40, 0x07, 0x20, 0xfa, 0xae, 0x6e, 0x5a, 0x9a, 0x4f, 0x3c, 0x5f, 0x0b, 0xb5,
	0xd6, 0xd6, 0xf6, 0x85, 0x03, 0x41, 0x2d, 0x84, 0xf4, 0x1e, 0xf1, 0x7c, 0x35, 0xa0, 0xa2, 0x1a,
	0xbc, 0xe3, 0xdd, 0x8d, 0x07, 0x83, 0x21, 0xa9, 0xad, 0xef, 0x0b, 0x07, 0x1b, 0x2a, 0x5f, 0xa2,
	0x3d, 0xc8, 0xbb, 0xba, 0x65, 0xd8, 0x23, 0xcd, 0x23, 0xc4, 0xa8, 0x65, 0x42, 0xfd, 0x40, 0x49,
	0x5d, 0x42, 0x0c, 0xb4, 0x0b, 0xe0, 0xf9, 0x81, 0xee, 0x81, 0x49, 0x8c, 0x5a, 0x36, 0x94, 0x9e,
	0xa1, 0xc8, 0x3f, 0x81, 0x4c, 0xe0, 0x1d, 0x41, 0x2f, 0x43, 0x77, 0x5c, 0xb3, 0x1f, 0xba, 0x93,
	0xaf, 0x3f, 0xc5, 0x1d, 0x1a, 0x94, 0x0e, 0x71, 0x07, 0xb6, 0x3b, 0xd2, 0xad, 0x3e, 0x79, 0x13,
	0x32, 0xa8, 0x8c, 0x11, 0xed, 0x40, 0x26, 0x8c, 0x54, 0xe8, 0x56, 0xbe, 0x9e, 0xc5, 0xd7, 0xc1,
	0x4a, 0xa5, 0x44, 0xf9, 0x77, 0x02, 0x14, 0xbb, 0xbe, 0xee, 0xfa, 0x5d, 0xe2, 0x79, 0xa6, 0x6d,
	0xa9, 0xe4, 0xe7, 0x63, 0xe2, 0xf9, 0xe8, 0x19, 0xc0, 0xd8, 0x23, 0xae, 0xa6, 0xdf, 0x12, 0xcb,
	0x0f, 0x0f, 0xcb, 0xa9, 0xb9, 0x80, 0x72, 0x12, 0x10, 0x02, 0x5f, 0xdf, 0x12, 0x37, 0x10, 0x08,
	0xd5, 0xe6, 0x54, 0xbe, 0x44, 0xc7, 0x50, 0xd4, 0x87, 0x43, 0xfb, 0x17, 0xc4, 0xd0, 0xc2, 0x13,
	0x34, 0xff, 0xde, 0x21, 0x5e, 0x6d, 0x6d, 0x7f, 0xed, 0xa0, 0x50, 0x07, 0x7a, 0x78, 0xef, 0xde,
	0x21, 0xea, 0x13, 0xc6, 0x36, 0xa1, 0x78, 0xf2, 0x5f, 0x83, 0x5b, 0x9c, 0x33, 0xc6, 0x73, 0x6c,
	0xcb, 0x23, 0x81, 0x35, 0x1e, 0x25, 0x69, 0xa6, 0xc1, 0xad, 0x61, 0x94, 0xa6, 0x11, 0x31, 0x36,
	0x9d, 0x60, 0xec, 0xda, 0x4a, 0xc6, 0xae, 0xaf, 0x62, 0x6c, 0x1d, 0x9e, 0x28, 0x96, 0xb1, 0x18,
	0xb6, 0x04, 0x43, 0xe5, 0x12, 0xa0, 0x59, 0x19, 0xea, 0x9d, 0xdc, 0x67, 0x57, 0xc0, 0xae, 0x72,
	0x35, 0x5d, 0xe8, 0xbb, 0xf0, 0x0e, 0xfb, 0x21, 0xd8, 0xcd, 0x16, 0x79, 0x2e, 0x34, 0xd8, 0xbf,
	0x17, 0x9c, 0xc1, 0x79, 0xe4, 0x1f, 0xb0, 0xd0, 0x4e, 0x0e, 0x99, 0x86, 0x96, 0xb1, 0xcc, 0x9c,
	0xc2, 0x28, 0x4d, 0x43, 0x36, 0xa0, 0x74, 0xe5, 0x18, 0xba, 0x4f, 0x16, 0x8d, 0x4b, 0x10, 0x7b,
	0xac, 0x71, 0x55, 0x28, 0x47, 0x4e, 0x61, 0xa1, 0xa1, 0x41, 0x7e, 0xd4, 0xd9, 0x2c, 0xc8, 0x51,
	0x4d, 0xbf, 0x15, 0xa0, 0xd2, 0x25, 0xba, 0xdb, 0xbf, 0xeb, 0xb0, 0x3a, 0xe3, 0xad, 0xe8, 0xcb,
	0x21, 0x6c, 0xf8, 0x64, 0xe4, 0x0c, 0x75, 0x9f, 0xff, 0x43, 0x25, 0xcc, 0x75, 0xcc, 0x7a, 0x33,
	0xe1, 0x42, 0xbb, 0x90, 0x35, 0x2d, 0x67, 0xec, 0xd3, 0xb4, 0x9f, 0xfe, 0x73, 0x8c, 0x2a, 0xbf,
	0x82, 0xea, 0x82, 0x29, 0xec, 0x3a, 0xb6, 0x21, 0xe7, 0x85, 0x5b, 0x53, 0x53, 0x36, 0x28, 0xa1,
	0x69, 0xc8, 0x47, 0xf0, 0x34, 0x4c, 0x9f, 0x58, 0x2f, 0x12, 0x25, 0x77, 0x40, 0x8a, 0x93, 0x64,
	0xb1, 0x79, 0x0d, 0x52, 0xd7, 0xb7, 0x9d, 0xaf, 0xa3, 0xf8, 0x19, 0x6c, 0xc7, 0x8a, 0x32, 0xcd,
	0xbf, 0x82, 0x22, 0x27, 0x52, 0x16, 0x5a, 0xc6, 0x3e, 0x85, 0xb2, 0x47, 0xab, 0xb5, 0xd6, 0x9f,
	0x2d, 0xd7, 0xac, 0xaa, 0x95, 0x71, 0x5c, 0x2d, 0x57, 0x4b, 0x5e, 0x5c, 0x85, 0xdf, 0x81, 0x4c,
	0x40, 0x9f, 0xd6, 0xb7, 0xf0, 0x08, 0x95, 0x12, 0xe5, 0x8f, 0x61, 0xff, 0x9c, 0xf8, 0x8b, 0xe6,
	0x8d, 0x87, 0xfe, 0x6a, 0x0e, 0xfe, 0x49, 0x80, 0xf7, 0x12, 0x34, 0xb0, 0x6b, 0xdb, 0x83, 0x3c,
	0x6f, 0x5f, 0x53, 0x25, 0xc0, 0x49, 0x4d, 0x03, 0x3d, 0x87, 0x82, 0x69, 0xf9, 0xc4, 0xb5, 0xf4,
	0xa1, 0x36, 0x35, 0x57, 0x50, 0x37, 0x39, 0x95, 0x06, 0xe6, 0x7d, 0xc8, 0x86, 0xbb, 0x3c, 0x73,
	0xa6, 0x99, 0x36, 0x13, 0x3e, 0x95, 0xf1, 0xc8, 0xc7, 0x50, 0xa5, 0x09, 0x78, 0x43, 0x38, 0x1b,
	0xf7, 0xe9, 0x21, 0x83, 0xe4, 0xbf, 0x09, 0x50, 0xeb, 0xf0, 0x0e, 0xdb, 0xf5, 0x89, 0x33, 0x93,
	0xca, 0xe8, 0x12, 0xf2, 0x77, 0xf7, 0x0e, 0x71, 0x1d, 0xdd, 0xd5, 0x47, 0x5e, 0x4d, 0x08, 0x6d,
	0x79, 0x81, 0x97, 0xf1, 0xe3, 0x8b, 0x29, 0xb3, 0x62, 0xf9, 0xee, 0xbd, 0x3a, 0x2b, 0x2e, 0x9d,
	0x81, 0x18, 0x65, 0x40, 0x22, 0xac, 0x7d, 0x41, 0xee, 0x99, 0x5d, 0xc1, 0x67, 0x72, 0x9f, 0x3a,
	0x4e, 0x1f, 0x09, 0x72, 0x03, 0xa4, 0xee, 0xf8, 0x86, 0xfb, 0x10, 0xb5, 0xf9, 0xdb, 0x90, 0xf1,
	0x7c, 0xe2, 0x70, 0x6b, 0x45, 0x1c, 0x61, 0x50, 0xe9, 0xb6, 0xfc, 0x07, 0x01, 0xb6, 0xa2, 0xb2,
	0xaf, 0x21, 0x37, 0x41, 0x1b, 0x33, 0x9d, 0x35, 0xde, 0xdb, 0x8b, 0x94, 0x3a, 0xe5, 0x46, 0xaf,
	0x61, 0x83, 0x5b, 0xc4, 0x2c, 0xdf, 0xc6, 0xcb, 0xad, 0xbc, 0x48, 0xa9, 0x13, 0xf6, 0x4f, 0xb2,
	0xb0, 0x1e, 0x98, 0x24, 0xfb, 0x50, 0x5b, 0xbc, 0x46, 0x96, 0x58, 0x87, 0x33, 0xea, 0x85, 0xa4,
	0xe2, 0xc3, 0xb9, 0xa6, 0x71, 0x48, 0x27, 0xc7, 0xe1, 0x4b, 0x01, 0xde, 0x0d, 0xb6, 0x3a, 0xae,
	0x7d, 0xeb, 0x12, 0xcf, 0x43, 0xcf, 0x61, 0xc3, 0x61, 0xdf, 0x0c, 0x2c, 0xe5, 0x30, 0xdf, 0x54,
	0x27, 0x5b, 0x41, 0x37, 0x1d, 0xe8, 0xe6, 0x70, 0xcc, 0x52, 0x38, 0xa7, 0xf2, 0x25, 0x3a, 0x0c,
	0x4e, 0xd6, 0x5d, 0x3f, 0xec, 0xb2, 0xf9, 0xba, 0x84, 0x29, 0xe4, 0xc3, 0x1c, 0xf2, 0xe1, 0x1e,
	0x87, 0x7c, 0x2a, 0x65, 0x44, 0xef, 0xc3, 0x1a, 0xb1, 0x8c, 0x10, 0x2e, 0x25, 0xf3, 0x07, 0x6c,
	0xe8, 0x5b, 0xdc, 0xb3, 0x4c, 0xe8, 0xd9, 0x26, 0x9e, 0x35, 0x9f, 0xbb, 0xd5, 0x85, 0xad, 0x49,
	0x10, 0xc7, 0xd6, 0x95, 0x47, 0x5c, 0x54, 0x80, 0xf4, 0xe4, 0x17, 0x48, 0x9b, 0x46, 0xe0, 0x41,
	0xff, 0xce, 0xb6, 0x3d, 0x42, 0xc1, 0xcb, 0x86, 0xca, 0x97, 0xa8, 0x02, 0x59, 0x97, 0xe8, 0xde,
	0x04, 0x28, 0xb0, 0x95, 0xfc, 0x9b, 0x34, 0x85, 0x97, 0x8f, 0xfe, 0xcd, 0x66, 0x5a, 0x41, 0x3a,
	0xae, 0x15, 0xa0, 0x4f, 0xa1, 0xe8, 0x4c, 0xa1, 0x9b, 0x46, 0x31, 0x1b, 0xff, 0xfb, 0x13, 0xd0,
	0x1d, 0x72, 0xa2, 0x24, 0x2f, 0xb8, 0xf9, 0x00, 0xf4, 0x50, 0xfc, 0x12, 0xdc, 0x7c, 0x24, 0x10,
	0x2a, 0xdd, 0x46, 0x3f, 0x84, 0xcd, 0xf9, 0xaa, 0x9b, 0x49, 0xaa, 0xba, 0xf3, 0xbc, 0xf2, 0x2b,
	0x28, 0x47, 0x22, 0x31, 0x05, 0x12, 0x2e, 0x8d, 0xca, 0x4c, 0x17, 0x65, 0x94, 0xa6, 0x21, 0x7f,
	0x0c, 0xbb, 0x41, 0x19, 0x8d, 0x88, 0xce, 0x96, 0xe1, 0x07, 0x14, 0x7c, 0x25, 0xc0, 0xde, 0x52,
	0x0d, 0xcc, 0x86, 0xff, 0xf9, 0x14, 0xde, 0x9d, 0xd4, 0xf7, 0x0c, 0x4b, 0x87, 0xf9, 0x8a, 0xfe,
	0x2f, 0x01, 0xd0, 0x99, 0xe9, 0xff, 0xc7, 0xd3, 0xec, 0x39, 0x14, 0xc8, 0x2f, 0x1d, 0xdb, 0x23,
	0x9a, 0x3d, 0xf6, 0x27, 0xc8, 0x24, 0xa7, 0x6e, 0x52, 0x6a, 0x9b, 0x12, 0xd1, 0x11, 0x20, 0xc6,
	0x96, 0x0c, 0x87, 0x45, 0xca, 0x35, 0x45, 0xc3, 0xd3, 0xdc, 0xcb, 0x24, 0xe6, 0x9e, 0xfc, 0x7d,
	0x28, 0xce, 0xf9, 0xb7, 0x5a, 0xf2, 0x7c, 0x04, 0x3b, 0xe7, 0xc4, 0x9f, 0x17, 0x7c, 0x44, 0xea,
	0xfc, 0x7e, 0x0d, 0x9e, 0x2d, 0x91, 0xff, 0x7f, 0x49, 0x9c, 0x55, 0x6a, 0x1f, 0xfa, 0x29, 0x6c,
	0xd1, 0x8b, 0x31, 0x26, 0xd7, 0x9c, 0x0d, 0xd9, 0xeb, 0x38, 0xd1, 0x7d, 0xac, 0x50, 0x29, 0x96,
	0x06, 0xb4, 0x85, 0xb3, 0x84, 0xe1, 0x44, 0xa9, 0x09, 0xc5, 0x18, 0xb6, 0xaf, 0xd5, 0xc8, 0xbf,
	0x12, 0xa0, 0xd2, 0x71, 0x6d, 0x63, 0xdc, 0x27, 0xdf, 0xdc, 0x4c, 0x3f, 0x82, 0xea, 0x82, 0x8f,
	0xab, 0x65, 0xfb, 0x49, 0x88, 0x59, 0x17, 0x85, 0x1f, 0x91, 0xf1, 0x7f, 0x5c, 0x0b, 0x51, 0xeb,
	0x32, 0x1d, 0xdf, 0xa8, 0xac, 0xd7, 0x96, 0x65, 0xfd, 0x2b, 0xfc, 0x60, 0x08, 0xfe, 0xdb, 0x99,
	0x7f, 0x09, 0x65, 0x6e, 0x49, 0xa0, 0xd2, 0xf5, 0x57, 0xce, 0x7b, 0x04, 0xeb, 0xae, 0x6e, 0x7d,
	0xc1, 0x86, 0x53, 0xe1, 0xb7, 0x5c, 0x83, 0x4a, 0x54, 0x1b, 0x7b, 0x77, 0xbd, 0x82, 0xf2, 0xa5,
	0xe9, 0xf9, 0x13, 0x08, 0xeb, 0xad, 0x38, 0xa0, 0x68, 0x40, 0x25, 0x2a, 0xc7, 0x72, 0xe5, 0x45,
	0xf0, 0x48, 0xe6, 0x54, 0x86, 0xb1, 0x61, 0x8a, 0x91, 0xd5, 0x99, 0xdd, 0x17, 0xbf, 0x16, 0x40,
	0x8c, 0x8e, 0xd9, 0xd0, 0x1e, 0x6c, 0x2b, 0xd7, 0x27, 0x97, 0x57, 0x27, 0xbd, 0x66, 0xbb, 0xa5,
	0xbd, 0x51, 0x7a, 0x17, 0xed, 0x86, 0x76, 0xd5, 0x6a, 0x28, 0x67, 0xcd, 0x96, 0xd2, 0x10, 0x53,
	0x28, 0x0f, 0xef, 0x5c, 0xb4, 0x2f, 0x1b, 0xed, 0xab, 0x9e, 0x28, 0x20, 0x80, 0xec, 0x67, 0xda,
	0x59, 0xfb, 0xb2, 0x21, 0xa6, 0xd1, 0x13, 0xd8, 0xbc, 0x54, 0x4e, 0xae, 0x15, 0xad, 0xdd, 0x52,
	0xb4, 0x60, 0xdb, 0x40, 0x05, 0x80, 0x8e, 0xaa, 0x34, 0x9a, 0xa7, 0x81, 0x32, 0x91, 0x04, 0x2c,
	0x3d, 0xf5, 0xa4, 0xd9, 0x6a, 0xb6, 0xce, 0xb5, 0xc6, 0x49, 0xef, 0x44, 0x1c, 0xbc, 0xb8, 0x86,
	0x8d, 0x09, 0xb4, 0x2d, 0x81, 0xd8, 0x51, 0xdb, 0xe7, 0xaa, 0xd2, 0xed, 0x6a, 0x57, 0xad, 0xcf,
	0x5a, 0xed, 0x1f, 0xb7, 0xe8, 0x81, 0x1d, 0xa5, 0xd5, 0x68, 0xb6, 0xce, 0x45, 0x21, 0x58, 0xa8,
	0x57, 0xad, 0x40, 0x81, 0x98, 0x46, 0x9b, 0x90, 0x3b, 0x6d, 0xbf, 0xe9, 0x5c, 0x2a, 0x3d, 0xa5,
	0x21, 0xae, 0x05, 0x7b, 0x8a, 0xaa, 0xb6, 0x55, 0xa5, 0x21, 0xae, 0xd7, 0xff, 0x01, 0xb0, 0x7e,
	0x1a, 0xbc, 0xd5, 0x3e, 0x0a, 0xf0, 0xf3, 0x74, 0x58, 0x85, 0x4a, 0x38, 0x66, 0x90, 0x26, 0x95,
	0x71, 0xdc, 0x44, 0x4b, 0x4e, 0xa1, 0x0f, 0x01, 0xa6, 0xb3, 0x20, 0x84, 0xf0, 0xc2, 0x30, 0x49,
	0x2a, 0xe2, 0x98, 0x61, 0x51, 0x6a, 0x72, 0x2e, 0xc3, 0x86, 0xfc, 0xdc, 0xf9, 0x21, 0x09, 0x3f,
	0x37, 0x3a, 0x06, 0x49, 0xa1, 0x1f, 0xc1, 0xe6, 0xdc, 0xac, 0x05, 0x95, 0x71, 0xdc, 0x84, 0x47,
	0xaa, 0xe0, 0xf8, 0x91, 0x0c, 0xb7, 0x9c, 0x8b, 0x87, 0x96, 0x47, 0x64, 0x8b, 0x38, 0x66, 0x02,
	0x93, 0x42, 0x67, 0xb0, 0x15, 0x79, 0x47, 0xa3, 0x2a, 0x8e, 0x9f, 0x3a, 0x48, 0x35, 0xbc, 0x6c,
	0xa6, 0x90, 0x42, 0x03, 0x78, 0xba, 0xf4, 0x49, 0x8e, 0xde, 0xc3, 0x0f, 0x3d, 0xf8, 0x25, 0x19,
	0x3f, 0xf8, 0xa2, 0x97, 0x53, 0x87, 0x02, 0x6a, 0xb3, 0x71, 0xdd, 0xbc, 0xc9, 0x12, 0x5e, 0x3a,
	0x84, 0x91, 0xb6, 0x71, 0xc2, 0x98, 0x25, 0x85, 0x54, 0x28, 0xc6, 0x4c, 0x4b, 0xd0, 0x36, 0x5e,
	0x3e, 0x7e, 0x91, 0x76, 0x70, 0xd2, 0x80, 0x25, 0x85, 0x9a, 0x20, 0x46, 0x5f, 0x8f, 0xa8, 0x86,
	0x97, 0xcc, 0x05, 0xa4, 0xa7, 0x78, 0xd9, 0x53, 0x93, 0xa6, 0xc6, 0x1c, 0xbc, 0x46, 0xf4, 0x49,
	0xb0, 0xa0, 0xa4, 0x82, 0x63, 0x9f, 0x00, 0x72, 0x0a, 0xfd, 0x0c, 0xaa, 0x4b, 0x30, 0x3a, 0xda,
	0xc3, 0xc9, 0xf8, 0x5f, 0xda, 0xc7, 0x0f, 0xc0, 0xfb, 0xf0, 0x4e, 0x8e, 0x21, 0x3f, 0x03, 0x64,
	0x50, 0x11, 0x2f, 0xc2, 0x65, 0xa9, 0x84, 0x63, 0x30, 0xa6, 0x9c, 0x42, 0x9f, 0x43, 0x39, 0x16,
	0x07, 0xa1, 0x67, 0x38, 0x09, 0x5e, 0x4a, 0xbb, 0xc9, 0xf0, 0x29, 0xb4, 0xeb, 0x0c, 0xb6, 0x22,
	0xad, 0x06, 0x55, 0x71, 0x3c, 0xc8, 0x91, 0x6a, 0x78, 0x09, 0x32, 0x98, 0xe4, 0x76, 0x7c, 0xd7,
	0xa2, 0xb9, 0x9d, 0x08, 0x0c, 0x68, 0x6e, 0x27, 0x37, 0xbd, 0xd0, 0xde, 0x53, 0x28, 0xcc, 0xf7,
	0x0e, 0x54, 0xc1, 0xb1, 0xad, 0x49, 0xaa, 0xe2, 0x25, 0x4d, 0x26, 0x15, 0x28, 0x99, 0x6f, 0x17,
	0xa8, 0x82, 0x63, 0xfb, 0x8e, 0x54, 0xc5, 0xf1, 0x7d, 0x45, 0x4e, 0x1d, 0x37, 0x41, 0x0c, 0xfb,
	0x7f, 0xdf, 0x1e, 0x6a, 0x7c, 0x30, 0xbf, 0xb3, 0x80, 0x0c, 0xce, 0xcc, 0x21, 0x69, 0x87, 0x03,
	0x0c, 0xaf, 0xf6, 0xe5, 0x5f, 0xe8, 0xf3, 0x7c, 0x8b, 0xcb, 0x5d, 0x53, 0xb1, 0x4f, 0xa4, 0x3f,
	0xff, 0x5d, 0x7a, 0xb7, 0x7e, 0xf8, 0xf2, 0x08, 0xbf, 0xc4, 0x1f, 0x6a, 0x8e, 0x4b, 0x3e, 0x9f,
	0xcc, 0x45, 0x6e, 0xb2, 0x21, 0xf3, 0xf7, 0xfe, 0x1d, 0x00, 0x00, 0xff, 0xff, 0x66, 0xab, 0x85,
	0x7c, 0xb7, 0x1a, 0x00, 0x00,
}
