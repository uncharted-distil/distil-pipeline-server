// Code generated by protoc-gen-go. DO NOT EDIT.
// source: pipeline_service.proto

/*
Package compute is a generated protocol buffer package.

It is generated from these files:
	pipeline_service.proto

It has these top-level messages:
	SessionContext
	Status
	Response
	SessionRequest
	PipelineCreateRequest
	Score
	PipelineCreated
	PipelineCreateResult
	PipelineExecuteRequest
	PipelineExecuteResult
*/
package pipeline

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type StatusCode int32

const (
	StatusCode_OK                  StatusCode = 0
	StatusCode_CANCELLED           StatusCode = 1
	StatusCode_SESSION_UNKNOWN     StatusCode = 2
	StatusCode_SESSION_ENDED       StatusCode = 3
	StatusCode_SESSION_EXPIRED     StatusCode = 4
	StatusCode_INVALID_ARGUMENT    StatusCode = 5
	StatusCode_RESOURCE_EXHAUSTED  StatusCode = 6
	StatusCode_UNAVAILABLE         StatusCode = 7
	StatusCode_FAILED_PRECONDITION StatusCode = 8
	StatusCode_OUT_OF_RANGE        StatusCode = 9
	StatusCode_UNIMPLEMENTED       StatusCode = 10
	StatusCode_INTERNAL            StatusCode = 11
	StatusCode_ABORTED             StatusCode = 12
	StatusCode_UNKNOWN             StatusCode = 13
)

var StatusCode_name = map[int32]string{
	0:  "OK",
	1:  "CANCELLED",
	2:  "SESSION_UNKNOWN",
	3:  "SESSION_ENDED",
	4:  "SESSION_EXPIRED",
	5:  "INVALID_ARGUMENT",
	6:  "RESOURCE_EXHAUSTED",
	7:  "UNAVAILABLE",
	8:  "FAILED_PRECONDITION",
	9:  "OUT_OF_RANGE",
	10: "UNIMPLEMENTED",
	11: "INTERNAL",
	12: "ABORTED",
	13: "UNKNOWN",
}
var StatusCode_value = map[string]int32{
	"OK":                  0,
	"CANCELLED":           1,
	"SESSION_UNKNOWN":     2,
	"SESSION_ENDED":       3,
	"SESSION_EXPIRED":     4,
	"INVALID_ARGUMENT":    5,
	"RESOURCE_EXHAUSTED":  6,
	"UNAVAILABLE":         7,
	"FAILED_PRECONDITION": 8,
	"OUT_OF_RANGE":        9,
	"UNIMPLEMENTED":       10,
	"INTERNAL":            11,
	"ABORTED":             12,
	"UNKNOWN":             13,
}

func (x StatusCode) String() string {
	return proto.EnumName(StatusCode_name, int32(x))
}
func (StatusCode) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type Progress int32

const (
	Progress_SUBMITTED Progress = 0
	Progress_RUNNING   Progress = 1
	Progress_COMPLETE  Progress = 2
)

var Progress_name = map[int32]string{
	0: "SUBMITTED",
	1: "RUNNING",
	2: "COMPLETE",
}
var Progress_value = map[string]int32{
	"SUBMITTED": 0,
	"RUNNING":   1,
	"COMPLETE":  2,
}

func (x Progress) String() string {
	return proto.EnumName(Progress_name, int32(x))
}
func (Progress) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type Task int32

const (
	Task_CLASSIFICATION Task = 0
	Task_REGRESSION     Task = 1
)

var Task_name = map[int32]string{
	0: "CLASSIFICATION",
	1: "REGRESSION",
}
var Task_value = map[string]int32{
	"CLASSIFICATION": 0,
	"REGRESSION":     1,
}

func (x Task) String() string {
	return proto.EnumName(Task_name, int32(x))
}
func (Task) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type Output int32

const (
	Output_CLASS_LABEL      Output = 0
	Output_PROBABILITY      Output = 1
	Output_GENERAL_SCORE    Output = 2
	Output_MULTILABEL       Output = 3
	Output_REGRESSION_VALUE Output = 4
)

var Output_name = map[int32]string{
	0: "CLASS_LABEL",
	1: "PROBABILITY",
	2: "GENERAL_SCORE",
	3: "MULTILABEL",
	4: "REGRESSION_VALUE",
}
var Output_value = map[string]int32{
	"CLASS_LABEL":      0,
	"PROBABILITY":      1,
	"GENERAL_SCORE":    2,
	"MULTILABEL":       3,
	"REGRESSION_VALUE": 4,
}

func (x Output) String() string {
	return proto.EnumName(Output_name, int32(x))
}
func (Output) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type Metric int32

const (
	Metric_ACCURACY              Metric = 0
	Metric_PRECISION             Metric = 1
	Metric_RECALL                Metric = 2
	Metric_F1_MICRO              Metric = 4
	Metric_F1_MACRO              Metric = 5
	Metric_ROC_AUC               Metric = 6
	Metric_LOG_LOSS              Metric = 7
	Metric_MEAN_SQUARED_ERR      Metric = 8
	Metric_ROOT_MEAN_SQUARED_ERR Metric = 9
	Metric_MEAN_ABSOLUTE_ERR     Metric = 10
	Metric_MEDIAN_ABSOSLUTE_ERR  Metric = 11
	Metric_R2                    Metric = 12
)

var Metric_name = map[int32]string{
	0:  "ACCURACY",
	1:  "PRECISION",
	2:  "RECALL",
	4:  "F1_MICRO",
	5:  "F1_MACRO",
	6:  "ROC_AUC",
	7:  "LOG_LOSS",
	8:  "MEAN_SQUARED_ERR",
	9:  "ROOT_MEAN_SQUARED_ERR",
	10: "MEAN_ABSOLUTE_ERR",
	11: "MEDIAN_ABSOSLUTE_ERR",
	12: "R2",
}
var Metric_value = map[string]int32{
	"ACCURACY":              0,
	"PRECISION":             1,
	"RECALL":                2,
	"F1_MICRO":              4,
	"F1_MACRO":              5,
	"ROC_AUC":               6,
	"LOG_LOSS":              7,
	"MEAN_SQUARED_ERR":      8,
	"ROOT_MEAN_SQUARED_ERR": 9,
	"MEAN_ABSOLUTE_ERR":     10,
	"MEDIAN_ABSOSLUTE_ERR":  11,
	"R2": 12,
}

func (x Metric) String() string {
	return proto.EnumName(Metric_name, int32(x))
}
func (Metric) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type SessionContext struct {
	SessionId string `protobuf:"bytes,1,opt,name=session_id,json=sessionId" json:"session_id,omitempty"`
}

func (m *SessionContext) Reset()                    { *m = SessionContext{} }
func (m *SessionContext) String() string            { return proto.CompactTextString(m) }
func (*SessionContext) ProtoMessage()               {}
func (*SessionContext) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *SessionContext) GetSessionId() string {
	if m != nil {
		return m.SessionId
	}
	return ""
}

type Status struct {
	Code    StatusCode `protobuf:"varint,1,opt,name=code,enum=compute.StatusCode" json:"code,omitempty"`
	Details string     `protobuf:"bytes,2,opt,name=details" json:"details,omitempty"`
}

func (m *Status) Reset()                    { *m = Status{} }
func (m *Status) String() string            { return proto.CompactTextString(m) }
func (*Status) ProtoMessage()               {}
func (*Status) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Status) GetCode() StatusCode {
	if m != nil {
		return m.Code
	}
	return StatusCode_OK
}

func (m *Status) GetDetails() string {
	if m != nil {
		return m.Details
	}
	return ""
}

type Response struct {
	Context *SessionContext `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	Status  *Status         `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *Response) Reset()                    { *m = Response{} }
func (m *Response) String() string            { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()               {}
func (*Response) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Response) GetContext() *SessionContext {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *Response) GetStatus() *Status {
	if m != nil {
		return m.Status
	}
	return nil
}

// in the future we could also pass arguments allowing one to fork an existing session,
// or provide resource limits on a session (asking TA2 system to terminate work if it exceeds a given limit)
type SessionRequest struct {
}

func (m *SessionRequest) Reset()                    { *m = SessionRequest{} }
func (m *SessionRequest) String() string            { return proto.CompactTextString(m) }
func (*SessionRequest) ProtoMessage()               {}
func (*SessionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type PipelineCreateRequest struct {
	Context          *SessionContext `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	TrainDatasetUris []string        `protobuf:"bytes,2,rep,name=train_dataset_uris,json=trainDatasetUris" json:"train_dataset_uris,omitempty"`
	Task             Task            `protobuf:"varint,3,opt,name=task,enum=compute.Task" json:"task,omitempty"`
	TaskDescription  string          `protobuf:"bytes,4,opt,name=task_description,json=taskDescription" json:"task_description,omitempty"`
	Output           Output          `protobuf:"varint,5,opt,name=output,enum=compute.Output" json:"output,omitempty"`
	Metric           []Metric        `protobuf:"varint,6,rep,packed,name=metric,enum=compute.Metric" json:"metric,omitempty"`
	TargetFeatures   []string        `protobuf:"bytes,7,rep,name=target_features,json=targetFeatures" json:"target_features,omitempty"`
	MaxPipelines     int32           `protobuf:"varint,8,opt,name=max_pipelines,json=maxPipelines" json:"max_pipelines,omitempty"`
}

func (m *PipelineCreateRequest) Reset()                    { *m = PipelineCreateRequest{} }
func (m *PipelineCreateRequest) String() string            { return proto.CompactTextString(m) }
func (*PipelineCreateRequest) ProtoMessage()               {}
func (*PipelineCreateRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *PipelineCreateRequest) GetContext() *SessionContext {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *PipelineCreateRequest) GetTrainDatasetUris() []string {
	if m != nil {
		return m.TrainDatasetUris
	}
	return nil
}

func (m *PipelineCreateRequest) GetTask() Task {
	if m != nil {
		return m.Task
	}
	return Task_CLASSIFICATION
}

func (m *PipelineCreateRequest) GetTaskDescription() string {
	if m != nil {
		return m.TaskDescription
	}
	return ""
}

func (m *PipelineCreateRequest) GetOutput() Output {
	if m != nil {
		return m.Output
	}
	return Output_CLASS_LABEL
}

func (m *PipelineCreateRequest) GetMetric() []Metric {
	if m != nil {
		return m.Metric
	}
	return nil
}

func (m *PipelineCreateRequest) GetTargetFeatures() []string {
	if m != nil {
		return m.TargetFeatures
	}
	return nil
}

func (m *PipelineCreateRequest) GetMaxPipelines() int32 {
	if m != nil {
		return m.MaxPipelines
	}
	return 0
}

type Score struct {
	Metric Metric  `protobuf:"varint,1,opt,name=metric,enum=compute.Metric" json:"metric,omitempty"`
	Value  float32 `protobuf:"fixed32,2,opt,name=value" json:"value,omitempty"`
}

func (m *Score) Reset()                    { *m = Score{} }
func (m *Score) String() string            { return proto.CompactTextString(m) }
func (*Score) ProtoMessage()               {}
func (*Score) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Score) GetMetric() Metric {
	if m != nil {
		return m.Metric
	}
	return Metric_ACCURACY
}

func (m *Score) GetValue() float32 {
	if m != nil {
		return m.Value
	}
	return 0
}

type PipelineCreated struct {
	PredictResultUris []string `protobuf:"bytes,1,rep,name=predict_result_uris,json=predictResultUris" json:"predict_result_uris,omitempty"`
	Output            Output   `protobuf:"varint,2,opt,name=output,enum=compute.Output" json:"output,omitempty"`
	Score             []*Score `protobuf:"bytes,3,rep,name=score" json:"score,omitempty"`
}

func (m *PipelineCreated) Reset()                    { *m = PipelineCreated{} }
func (m *PipelineCreated) String() string            { return proto.CompactTextString(m) }
func (*PipelineCreated) ProtoMessage()               {}
func (*PipelineCreated) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *PipelineCreated) GetPredictResultUris() []string {
	if m != nil {
		return m.PredictResultUris
	}
	return nil
}

func (m *PipelineCreated) GetOutput() Output {
	if m != nil {
		return m.Output
	}
	return Output_CLASS_LABEL
}

func (m *PipelineCreated) GetScore() []*Score {
	if m != nil {
		return m.Score
	}
	return nil
}

type PipelineCreateResult struct {
	ResponseInfo *Response `protobuf:"bytes,1,opt,name=response_info,json=responseInfo" json:"response_info,omitempty"`
	ProgressInfo Progress  `protobuf:"varint,2,opt,name=progress_info,json=progressInfo,enum=compute.Progress" json:"progress_info,omitempty"`
	PipelineId   string    `protobuf:"bytes,3,opt,name=pipeline_id,json=pipelineId" json:"pipeline_id,omitempty"`
	// Will be set if progress info is a value other than COMPLETE
	PipelineInfo *PipelineCreated `protobuf:"bytes,4,opt,name=pipeline_info,json=pipelineInfo" json:"pipeline_info,omitempty"`
}

func (m *PipelineCreateResult) Reset()                    { *m = PipelineCreateResult{} }
func (m *PipelineCreateResult) String() string            { return proto.CompactTextString(m) }
func (*PipelineCreateResult) ProtoMessage()               {}
func (*PipelineCreateResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *PipelineCreateResult) GetResponseInfo() *Response {
	if m != nil {
		return m.ResponseInfo
	}
	return nil
}

func (m *PipelineCreateResult) GetProgressInfo() Progress {
	if m != nil {
		return m.ProgressInfo
	}
	return Progress_SUBMITTED
}

func (m *PipelineCreateResult) GetPipelineId() string {
	if m != nil {
		return m.PipelineId
	}
	return ""
}

func (m *PipelineCreateResult) GetPipelineInfo() *PipelineCreated {
	if m != nil {
		return m.PipelineInfo
	}
	return nil
}

type PipelineExecuteRequest struct {
	Context            *SessionContext `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	PipelineId         string          `protobuf:"bytes,2,opt,name=pipeline_id,json=pipelineId" json:"pipeline_id,omitempty"`
	PredictDatasetUris []string        `protobuf:"bytes,3,rep,name=predict_dataset_uris,json=predictDatasetUris" json:"predict_dataset_uris,omitempty"`
}

func (m *PipelineExecuteRequest) Reset()                    { *m = PipelineExecuteRequest{} }
func (m *PipelineExecuteRequest) String() string            { return proto.CompactTextString(m) }
func (*PipelineExecuteRequest) ProtoMessage()               {}
func (*PipelineExecuteRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *PipelineExecuteRequest) GetContext() *SessionContext {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *PipelineExecuteRequest) GetPipelineId() string {
	if m != nil {
		return m.PipelineId
	}
	return ""
}

func (m *PipelineExecuteRequest) GetPredictDatasetUris() []string {
	if m != nil {
		return m.PredictDatasetUris
	}
	return nil
}

type PipelineExecuteResult struct {
	ResponseInfo *Response `protobuf:"bytes,1,opt,name=response_info,json=responseInfo" json:"response_info,omitempty"`
	ProgressInfo Progress  `protobuf:"varint,2,opt,name=progress_info,json=progressInfo,enum=compute.Progress" json:"progress_info,omitempty"`
	PipelineId   string    `protobuf:"bytes,3,opt,name=pipeline_id,json=pipelineId" json:"pipeline_id,omitempty"`
	// Will be set if progress info is value is COMPLETE
	ResultUris []string `protobuf:"bytes,4,rep,name=result_uris,json=resultUris" json:"result_uris,omitempty"`
}

func (m *PipelineExecuteResult) Reset()                    { *m = PipelineExecuteResult{} }
func (m *PipelineExecuteResult) String() string            { return proto.CompactTextString(m) }
func (*PipelineExecuteResult) ProtoMessage()               {}
func (*PipelineExecuteResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *PipelineExecuteResult) GetResponseInfo() *Response {
	if m != nil {
		return m.ResponseInfo
	}
	return nil
}

func (m *PipelineExecuteResult) GetProgressInfo() Progress {
	if m != nil {
		return m.ProgressInfo
	}
	return Progress_SUBMITTED
}

func (m *PipelineExecuteResult) GetPipelineId() string {
	if m != nil {
		return m.PipelineId
	}
	return ""
}

func (m *PipelineExecuteResult) GetResultUris() []string {
	if m != nil {
		return m.ResultUris
	}
	return nil
}

func init() {
	proto.RegisterType((*SessionContext)(nil), "compute.SessionContext")
	proto.RegisterType((*Status)(nil), "compute.Status")
	proto.RegisterType((*Response)(nil), "compute.Response")
	proto.RegisterType((*SessionRequest)(nil), "compute.SessionRequest")
	proto.RegisterType((*PipelineCreateRequest)(nil), "compute.PipelineCreateRequest")
	proto.RegisterType((*Score)(nil), "compute.Score")
	proto.RegisterType((*PipelineCreated)(nil), "compute.PipelineCreated")
	proto.RegisterType((*PipelineCreateResult)(nil), "compute.PipelineCreateResult")
	proto.RegisterType((*PipelineExecuteRequest)(nil), "compute.PipelineExecuteRequest")
	proto.RegisterType((*PipelineExecuteResult)(nil), "compute.PipelineExecuteResult")
	proto.RegisterEnum("compute.StatusCode", StatusCode_name, StatusCode_value)
	proto.RegisterEnum("compute.Progress", Progress_name, Progress_value)
	proto.RegisterEnum("compute.Task", Task_name, Task_value)
	proto.RegisterEnum("compute.Output", Output_name, Output_value)
	proto.RegisterEnum("compute.Metric", Metric_name, Metric_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for PipelineCompute service

type PipelineComputeClient interface {
	// Train step - multiple result messages returned via GRPC streaming.
	CreatePipelines(ctx context.Context, in *PipelineCreateRequest, opts ...grpc.CallOption) (PipelineCompute_CreatePipelinesClient, error)
	// Predict step - multiple results messages returned via GRPC streaming.
	ExecutePipeline(ctx context.Context, in *PipelineExecuteRequest, opts ...grpc.CallOption) (PipelineCompute_ExecutePipelineClient, error)
	// Session management
	StartSession(ctx context.Context, in *SessionRequest, opts ...grpc.CallOption) (*Response, error)
	EndSession(ctx context.Context, in *SessionContext, opts ...grpc.CallOption) (*Response, error)
}

type pipelineComputeClient struct {
	cc *grpc.ClientConn
}

func NewPipelineComputeClient(cc *grpc.ClientConn) PipelineComputeClient {
	return &pipelineComputeClient{cc}
}

func (c *pipelineComputeClient) CreatePipelines(ctx context.Context, in *PipelineCreateRequest, opts ...grpc.CallOption) (PipelineCompute_CreatePipelinesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_PipelineCompute_serviceDesc.Streams[0], c.cc, "/compute.PipelineCompute/CreatePipelines", opts...)
	if err != nil {
		return nil, err
	}
	x := &pipelineComputeCreatePipelinesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type PipelineCompute_CreatePipelinesClient interface {
	Recv() (*PipelineCreateResult, error)
	grpc.ClientStream
}

type pipelineComputeCreatePipelinesClient struct {
	grpc.ClientStream
}

func (x *pipelineComputeCreatePipelinesClient) Recv() (*PipelineCreateResult, error) {
	m := new(PipelineCreateResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *pipelineComputeClient) ExecutePipeline(ctx context.Context, in *PipelineExecuteRequest, opts ...grpc.CallOption) (PipelineCompute_ExecutePipelineClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_PipelineCompute_serviceDesc.Streams[1], c.cc, "/compute.PipelineCompute/ExecutePipeline", opts...)
	if err != nil {
		return nil, err
	}
	x := &pipelineComputeExecutePipelineClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type PipelineCompute_ExecutePipelineClient interface {
	Recv() (*PipelineExecuteResult, error)
	grpc.ClientStream
}

type pipelineComputeExecutePipelineClient struct {
	grpc.ClientStream
}

func (x *pipelineComputeExecutePipelineClient) Recv() (*PipelineExecuteResult, error) {
	m := new(PipelineExecuteResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *pipelineComputeClient) StartSession(ctx context.Context, in *SessionRequest, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := grpc.Invoke(ctx, "/compute.PipelineCompute/StartSession", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelineComputeClient) EndSession(ctx context.Context, in *SessionContext, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := grpc.Invoke(ctx, "/compute.PipelineCompute/EndSession", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for PipelineCompute service

type PipelineComputeServer interface {
	// Train step - multiple result messages returned via GRPC streaming.
	CreatePipelines(*PipelineCreateRequest, PipelineCompute_CreatePipelinesServer) error
	// Predict step - multiple results messages returned via GRPC streaming.
	ExecutePipeline(*PipelineExecuteRequest, PipelineCompute_ExecutePipelineServer) error
	// Session management
	StartSession(context.Context, *SessionRequest) (*Response, error)
	EndSession(context.Context, *SessionContext) (*Response, error)
}

func RegisterPipelineComputeServer(s *grpc.Server, srv PipelineComputeServer) {
	s.RegisterService(&_PipelineCompute_serviceDesc, srv)
}

func _PipelineCompute_CreatePipelines_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PipelineCreateRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PipelineComputeServer).CreatePipelines(m, &pipelineComputeCreatePipelinesServer{stream})
}

type PipelineCompute_CreatePipelinesServer interface {
	Send(*PipelineCreateResult) error
	grpc.ServerStream
}

type pipelineComputeCreatePipelinesServer struct {
	grpc.ServerStream
}

func (x *pipelineComputeCreatePipelinesServer) Send(m *PipelineCreateResult) error {
	return x.ServerStream.SendMsg(m)
}

func _PipelineCompute_ExecutePipeline_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PipelineExecuteRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PipelineComputeServer).ExecutePipeline(m, &pipelineComputeExecutePipelineServer{stream})
}

type PipelineCompute_ExecutePipelineServer interface {
	Send(*PipelineExecuteResult) error
	grpc.ServerStream
}

type pipelineComputeExecutePipelineServer struct {
	grpc.ServerStream
}

func (x *pipelineComputeExecutePipelineServer) Send(m *PipelineExecuteResult) error {
	return x.ServerStream.SendMsg(m)
}

func _PipelineCompute_StartSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelineComputeServer).StartSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/compute.PipelineCompute/StartSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelineComputeServer).StartSession(ctx, req.(*SessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipelineCompute_EndSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionContext)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelineComputeServer).EndSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/compute.PipelineCompute/EndSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelineComputeServer).EndSession(ctx, req.(*SessionContext))
	}
	return interceptor(ctx, in, info, handler)
}

var _PipelineCompute_serviceDesc = grpc.ServiceDesc{
	ServiceName: "compute.PipelineCompute",
	HandlerType: (*PipelineComputeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StartSession",
			Handler:    _PipelineCompute_StartSession_Handler,
		},
		{
			MethodName: "EndSession",
			Handler:    _PipelineCompute_EndSession_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "CreatePipelines",
			Handler:       _PipelineCompute_CreatePipelines_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ExecutePipeline",
			Handler:       _PipelineCompute_ExecutePipeline_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "pipeline_service.proto",
}

func init() { proto.RegisterFile("pipeline_service.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1135 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x56, 0xcd, 0x6e, 0xdb, 0x46,
	0x10, 0x36, 0xa9, 0x3f, 0x6b, 0x24, 0x59, 0xeb, 0xb5, 0x93, 0xb0, 0x01, 0x92, 0xb8, 0x6c, 0x81,
	0xb8, 0x46, 0xe1, 0x26, 0x6e, 0xd1, 0x43, 0xd1, 0x1e, 0x56, 0xe4, 0xda, 0x25, 0x42, 0x91, 0xee,
	0x92, 0x74, 0x93, 0xd3, 0x82, 0x15, 0xd7, 0x01, 0x11, 0x5b, 0x54, 0x49, 0x2a, 0xf0, 0x0b, 0xf4,
	0xde, 0x27, 0xe8, 0x7b, 0xf4, 0x11, 0x7a, 0xed, 0x43, 0xe4, 0x39, 0x8a, 0x5d, 0x92, 0x92, 0x7f,
	0xea, 0x1e, 0xda, 0x4b, 0x4f, 0x02, 0xe7, 0xfb, 0x66, 0xf6, 0xdb, 0x6f, 0x67, 0x06, 0x82, 0x87,
	0x8b, 0x74, 0x21, 0x2e, 0xd2, 0xb9, 0xe0, 0x85, 0xc8, 0xdf, 0xa7, 0x33, 0x71, 0xb8, 0xc8, 0xb3,
	0x32, 0xc3, 0xbd, 0x59, 0x76, 0xb9, 0x58, 0x96, 0xc2, 0xfc, 0x02, 0xb6, 0x02, 0x51, 0x14, 0x69,
	0x36, 0xb7, 0xb2, 0x79, 0x29, 0xae, 0x4a, 0xfc, 0x04, 0xa0, 0xa8, 0x22, 0x3c, 0x4d, 0x0c, 0x6d,
	0x4f, 0xdb, 0xef, 0xb3, 0x7e, 0x1d, 0x71, 0x12, 0xf3, 0x15, 0x74, 0x83, 0x32, 0x2e, 0x97, 0x05,
	0x7e, 0x0e, 0xed, 0x59, 0x96, 0x08, 0x45, 0xd9, 0x3a, 0xda, 0x39, 0xac, 0x4b, 0x1e, 0x56, 0xb0,
	0x95, 0x25, 0x82, 0x29, 0x02, 0x36, 0xa0, 0x97, 0x88, 0x32, 0x4e, 0x2f, 0x0a, 0x43, 0x57, 0xe5,
	0x9a, 0x4f, 0xf3, 0x1c, 0x36, 0x99, 0x28, 0x16, 0xd9, 0xbc, 0x10, 0xf8, 0x25, 0xf4, 0x66, 0x95,
	0x04, 0x55, 0x71, 0x70, 0xf4, 0x68, 0x5d, 0xf1, 0x86, 0x42, 0xd6, 0xf0, 0xf0, 0x73, 0xe8, 0x16,
	0xea, 0x30, 0x55, 0x77, 0x70, 0x34, 0xbe, 0xa5, 0x81, 0xd5, 0xb0, 0x89, 0x56, 0xb7, 0x64, 0xe2,
	0xe7, 0xa5, 0x28, 0x4a, 0xf3, 0x83, 0x0e, 0x0f, 0x4e, 0x6b, 0x6f, 0xac, 0x5c, 0xc4, 0xa5, 0xa8,
	0x91, 0x7f, 0xa3, 0xe3, 0x73, 0xc0, 0x65, 0x1e, 0xa7, 0x73, 0x9e, 0xc4, 0x65, 0x5c, 0x88, 0x92,
	0x2f, 0xf3, 0x54, 0x6a, 0x6a, 0xed, 0xf7, 0x19, 0x52, 0x88, 0x5d, 0x01, 0x51, 0x9e, 0x16, 0xf8,
	0x63, 0x68, 0x97, 0x71, 0xf1, 0xce, 0x68, 0x29, 0xdf, 0x46, 0xab, 0xea, 0x61, 0x5c, 0xbc, 0x63,
	0x0a, 0xc2, 0x9f, 0x01, 0x92, 0xbf, 0x3c, 0x11, 0xc5, 0x2c, 0x4f, 0x17, 0x65, 0x9a, 0xcd, 0x8d,
	0xb6, 0xb2, 0x6e, 0x2c, 0xe3, 0xf6, 0x3a, 0x2c, 0x3d, 0xc8, 0x96, 0xe5, 0x62, 0x59, 0x1a, 0x1d,
	0x55, 0x6f, 0xed, 0x81, 0xaf, 0xc2, 0xac, 0x86, 0x25, 0xf1, 0x52, 0x94, 0x79, 0x3a, 0x33, 0xba,
	0x7b, 0xad, 0x1b, 0xc4, 0xa9, 0x0a, 0xb3, 0x1a, 0xc6, 0xcf, 0x61, 0x5c, 0xc6, 0xf9, 0x5b, 0x51,
	0xf2, 0x73, 0x11, 0x97, 0xcb, 0x5c, 0x14, 0x46, 0x4f, 0x5d, 0x65, 0xab, 0x0a, 0x1f, 0xd7, 0x51,
	0xfc, 0x09, 0x8c, 0x2e, 0xe3, 0x2b, 0xde, 0xb4, 0x58, 0x61, 0x6c, 0xee, 0x69, 0xfb, 0x1d, 0x36,
	0xbc, 0x8c, 0xaf, 0x1a, 0x6b, 0x0b, 0xf3, 0x18, 0x3a, 0xc1, 0x2c, 0xcb, 0xc5, 0xb5, 0xf3, 0xb5,
	0x5b, 0x42, 0x6f, 0x9d, 0xbf, 0x0b, 0x9d, 0xf7, 0xf1, 0xc5, 0x52, 0xa8, 0x47, 0xd5, 0x59, 0xf5,
	0x61, 0xfe, 0xaa, 0xc1, 0xf8, 0xe6, 0x83, 0x25, 0xf8, 0x10, 0x76, 0x16, 0xb9, 0x48, 0xd2, 0x59,
	0xc9, 0x73, 0x51, 0x2c, 0x2f, 0x6a, 0xe3, 0x35, 0xa5, 0x76, 0xbb, 0x86, 0x98, 0x42, 0x94, 0xf3,
	0x6b, 0xaf, 0xf4, 0x7f, 0xf6, 0xea, 0x53, 0xe8, 0x14, 0x52, 0xb4, 0xd1, 0xda, 0x6b, 0xed, 0x0f,
	0x8e, 0xb6, 0xd6, 0x1d, 0x20, 0xa3, 0xac, 0x02, 0xcd, 0x0f, 0x1a, 0xec, 0xde, 0xee, 0x21, 0x79,
	0x16, 0xfe, 0x1a, 0x46, 0x79, 0xdd, 0xd6, 0x3c, 0x9d, 0x9f, 0x67, 0x75, 0x23, 0x6d, 0xaf, 0xca,
	0x34, 0x4d, 0xcf, 0x86, 0x0d, 0xcf, 0x99, 0x9f, 0x67, 0x32, 0x6f, 0x91, 0x67, 0x6f, 0x73, 0x51,
	0x14, 0x55, 0x5e, 0x25, 0x73, 0x9d, 0x77, 0x5a, 0xa3, 0x6c, 0xd8, 0xf0, 0x54, 0xde, 0x33, 0x18,
	0xac, 0xe6, 0x3c, 0x4d, 0x54, 0x63, 0xf5, 0x19, 0x34, 0x21, 0x27, 0xc1, 0xdf, 0xc1, 0x68, 0x4d,
	0x90, 0x85, 0xdb, 0x4a, 0x90, 0xb1, 0x2e, 0x7c, 0xd3, 0x59, 0x36, 0x5c, 0x25, 0xcf, 0xcf, 0x33,
	0xf3, 0x37, 0x0d, 0x1e, 0x36, 0x0c, 0x7a, 0x25, 0x66, 0xcb, 0xff, 0x34, 0x2d, 0xb7, 0xd4, 0xea,
	0x77, 0xd4, 0xbe, 0x80, 0xdd, 0xe6, 0x59, 0x6f, 0x0c, 0x54, 0x4b, 0xbd, 0x2b, 0xae, 0xb1, 0x6b,
	0x23, 0x65, 0xfe, 0xa1, 0xad, 0xa7, 0x79, 0x25, 0xf0, 0xff, 0xf9, 0x14, 0xcf, 0x60, 0x70, 0xbd,
	0x57, 0xdb, 0xea, 0x4e, 0x90, 0xaf, 0x9a, 0xf4, 0xe0, 0x17, 0x1d, 0x60, 0xbd, 0x42, 0x71, 0x17,
	0x74, 0xff, 0x15, 0xda, 0xc0, 0x23, 0xe8, 0x5b, 0xc4, 0xb3, 0xa8, 0xeb, 0x52, 0x1b, 0x69, 0x78,
	0x07, 0xc6, 0x01, 0x0d, 0x02, 0xc7, 0xf7, 0x78, 0xe4, 0xbd, 0xf2, 0xfc, 0x1f, 0x3d, 0xa4, 0xe3,
	0x6d, 0x18, 0x35, 0x41, 0xea, 0xd9, 0xd4, 0x46, 0xad, 0xeb, 0x3c, 0xfa, 0xfa, 0xd4, 0x61, 0xd4,
	0x46, 0x6d, 0xbc, 0x0b, 0xc8, 0xf1, 0xce, 0x88, 0xeb, 0xd8, 0x9c, 0xb0, 0x93, 0x68, 0x4a, 0xbd,
	0x10, 0x75, 0xf0, 0x43, 0xc0, 0x8c, 0x06, 0x7e, 0xc4, 0x2c, 0xca, 0xe9, 0xeb, 0xef, 0x49, 0x14,
	0x84, 0xd4, 0x46, 0x5d, 0x3c, 0x86, 0x41, 0xe4, 0x91, 0x33, 0xe2, 0xb8, 0x64, 0xe2, 0x52, 0xd4,
	0xc3, 0x8f, 0x60, 0xe7, 0x98, 0x38, 0x2e, 0xb5, 0xf9, 0x29, 0xa3, 0x96, 0xef, 0xd9, 0x4e, 0xe8,
	0xf8, 0x1e, 0xda, 0xc4, 0x08, 0x86, 0x7e, 0x14, 0x72, 0xff, 0x98, 0x33, 0xe2, 0x9d, 0x50, 0xd4,
	0x97, 0x8a, 0x22, 0xcf, 0x99, 0x9e, 0xba, 0x54, 0x1e, 0x42, 0x6d, 0x04, 0x78, 0x08, 0x9b, 0x8e,
	0x17, 0x52, 0xe6, 0x11, 0x17, 0x0d, 0xf0, 0x00, 0x7a, 0x64, 0xe2, 0x33, 0x09, 0x0d, 0xe5, 0x47,
	0x73, 0x99, 0xd1, 0xc1, 0x57, 0xb0, 0xd9, 0x78, 0x2c, 0x2f, 0x1f, 0x44, 0x93, 0xa9, 0x13, 0x4a,
	0xde, 0x86, 0xe4, 0xb1, 0xc8, 0xf3, 0x1c, 0xef, 0x04, 0x69, 0xb2, 0x9e, 0xe5, 0xcb, 0x13, 0x42,
	0x8a, 0xf4, 0x83, 0x03, 0x68, 0xcb, 0x3d, 0x8a, 0x31, 0x6c, 0x59, 0x2e, 0x09, 0x02, 0xe7, 0xd8,
	0xb1, 0x88, 0x92, 0xb7, 0x81, 0xb7, 0x00, 0x18, 0x3d, 0x61, 0x95, 0x1d, 0x48, 0x3b, 0x98, 0x41,
	0xb7, 0x9a, 0x7b, 0x79, 0x45, 0xc5, 0xe6, 0x2e, 0x99, 0x50, 0x17, 0x6d, 0xc8, 0xc0, 0x29, 0xf3,
	0x27, 0x64, 0xe2, 0xb8, 0x4e, 0xf8, 0x06, 0x69, 0xf2, 0x22, 0x27, 0xd4, 0xa3, 0x8c, 0xb8, 0x3c,
	0xb0, 0x7c, 0x46, 0x91, 0x2e, 0xcb, 0x4d, 0x23, 0x37, 0x74, 0xaa, 0x9c, 0x96, 0x74, 0x75, 0x5d,
	0x9e, 0x9f, 0x11, 0x37, 0xa2, 0xa8, 0x7d, 0xf0, 0xa7, 0x06, 0xdd, 0x6a, 0xc1, 0x49, 0xa5, 0xc4,
	0xb2, 0x22, 0x46, 0xac, 0x37, 0xd5, 0x83, 0x4a, 0xfb, 0x9c, 0x4a, 0x0c, 0x06, 0xe8, 0x32, 0x6a,
	0x11, 0xd7, 0x45, 0xba, 0x24, 0x1e, 0xbf, 0xe4, 0x53, 0xc7, 0x62, 0x3e, 0x6a, 0x37, 0x5f, 0x44,
	0x7e, 0x75, 0xd4, 0xdd, 0x7d, 0x8b, 0x93, 0xc8, 0x42, 0x5d, 0x09, 0xb9, 0xfe, 0x09, 0x77, 0xfd,
	0x20, 0x40, 0x3d, 0x29, 0x60, 0x4a, 0x89, 0xc7, 0x83, 0x1f, 0x22, 0xc2, 0xa8, 0xcd, 0x29, 0x63,
	0x68, 0x13, 0x7f, 0x04, 0x0f, 0x98, 0xef, 0x87, 0xfc, 0x0e, 0xd4, 0xc7, 0x0f, 0x60, 0x5b, 0x45,
	0xc9, 0x24, 0xf0, 0xdd, 0x28, 0xa4, 0x2a, 0x0c, 0xd8, 0x80, 0xdd, 0x29, 0xb5, 0x9d, 0x1a, 0x08,
	0x56, 0xc8, 0x40, 0x36, 0x23, 0x3b, 0x42, 0xc3, 0xa3, 0xdf, 0xf5, 0x6b, 0xcb, 0xb8, 0x1a, 0x08,
	0x1c, 0xc2, 0xb8, 0xda, 0x1e, 0xab, 0xdd, 0x8f, 0x9f, 0xde, 0xb3, 0x5f, 0xea, 0xe5, 0xf1, 0xf8,
	0xc9, 0xbd, 0xb8, 0x9c, 0x06, 0x73, 0xe3, 0x85, 0x86, 0xcf, 0x60, 0x5c, 0x0f, 0x74, 0x43, 0xc1,
	0xcf, 0xee, 0x64, 0xdd, 0xdc, 0x49, 0x8f, 0x9f, 0xde, 0x4f, 0x58, 0xd5, 0xfd, 0x16, 0x86, 0x41,
	0x19, 0xe7, 0x65, 0xbd, 0xa4, 0xf0, 0x9d, 0xb5, 0xd5, 0x14, 0xbb, 0xbb, 0x29, 0xcc, 0x0d, 0xfc,
	0x0d, 0x00, 0x9d, 0x27, 0xf7, 0xe6, 0xd6, 0x2b, 0xef, 0x6f, 0x73, 0x7f, 0xea, 0xaa, 0x7f, 0x60,
	0x5f, 0xfe, 0x15, 0x00, 0x00, 0xff, 0xff, 0xe7, 0x76, 0x48, 0x64, 0x9b, 0x09, 0x00, 0x00,
}
